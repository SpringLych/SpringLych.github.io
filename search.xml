<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[数据结构与算法之快速排序及其改进]]></title>
      <url>/2018/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种经典的排序方式<br><a id="more"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> i = left, j = right;</div><div class="line">        Comparable x = data[left];</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="comment">//i&lt;j  从右向左找到第一个小于x的数data[j]</span></div><div class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; data[j].compareTo(x) &gt;= <span class="number">0</span>) j--;</div><div class="line">            <span class="comment">//i&lt;j 将找到的data[j]给</span></div><div class="line">            <span class="keyword">if</span> (i &lt; j) data[i++] = data[j];</div><div class="line">            <span class="comment">//从左向右找到第一个大于x得数，data[i]</span></div><div class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i].compareTo(x) &lt;= <span class="number">0</span>) i++;</div><div class="line">            <span class="keyword">if</span> (i &lt; j) data[j--] = data[i];</div><div class="line">        &#125;</div><div class="line">        data[i] = x;</div><div class="line">        <span class="comment">//data[0...i-1] &lt; data[i] &lt; data[i+1...high]</span></div><div class="line">        quickSort(data, left, i - <span class="number">1</span>);</div><div class="line">        quickSort(data, i + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="改进-三向切分快速排序"><a href="#改进-三向切分快速排序" class="headerlink" title="改进 三向切分快速排序"></a>改进 三向切分快速排序</h3><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a[i] &lt; v，将 a[lt] 和 a[i]交换 lt 和 i 加一</span></div><div class="line"><span class="comment">//a[i] &gt; v，将 a[gt] 和 a[i]交换 gt减一</span></div><div class="line"><span class="comment">//a[i] = v，i++</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort3way</span><span class="params">(T data[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right)&#123;</div><div class="line">        <span class="keyword">int</span> lt = left, i = left + <span class="number">1</span>, gt = right;</div><div class="line">        T x = data[left];</div><div class="line">        <span class="keyword">while</span> (i &lt;= gt)&#123;</div><div class="line">            <span class="keyword">int</span> compar = data[i].compareTo(x);</div><div class="line">            <span class="keyword">if</span> (compar &lt; <span class="number">0</span>) swap(data, lt++, i++);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (compar &gt; <span class="number">0</span>) swap(data, i, gt--);</div><div class="line">            <span class="keyword">else</span> i ++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//data[0...lt - 1] &lt; data[lt...gt] &lt; data[gt+1...right]</span></div><div class="line">        quickSort3way(data, left, lt - <span class="number">1</span>);</div><div class="line">        quickSort3way(data, gt + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    T temp = a[i];</div><div class="line">    a[i] = a[j];</div><div class="line">    a[j] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树遍历]]></title>
      <url>/2018/03/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<p>二叉树基本的遍历方式如前序遍历，中序遍历，后序遍历，以及层序遍历。<br><a id="more"></a></p>
<p>前序遍历：访问根结点-&gt;访问左子树-&gt;访问右子树<br>中序遍历：访问左子树-&gt;访问根结点-&gt;访问右子树<br>后序遍历：访问左子树-&gt;访问右子树-&gt;访问根节点</p>
<p>一般遍历采用递归方式，而递归又可以使用栈转化为非递归方式，栈的效率越高，非递归方式的效率越高。对于层序遍历，一般使用队列。</p>
<h2 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prePrint</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    System.out.println(node.data);</div><div class="line">    prePrint(node.left);</div><div class="line">    prePrint(node.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midPrint</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    midPrint(node.left);</div><div class="line">    System.out.println(node.data);</div><div class="line">    midPrint(node.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//后序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">laPrint</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    laPrint(node.left);</div><div class="line">    laPrint(node.right);</div><div class="line">    System.out.println(node.data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure>
<h2 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h2><p>使用java.util.Stack实现栈</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>使用非递归实现遍历二叉树，对任意节点node:</p>
<ol>
<li>声明一个p节点指向node</li>
<li>访问节点p，将节点p入栈</li>
<li>判断栈或p节点有一方是否不为空，有一方不为空则进入下一判断，直至栈或p节点都为空</li>
<li>判断p节点是否空，p节点不为空，则输入p节点的数据，同时p节点入栈，p指向p的左节点，直至p节点为空（此时二叉树最左边的左孩子已经入栈）</li>
<li>判断栈是否为空，不为空取出栈顶节点并使p指向栈顶节点的右节点，直至栈为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 非递归实现前序遍历</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> node 访问节点</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderStack</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&lt;T&gt;&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Node&lt;T&gt; p = node;</div><div class="line">    <span class="keyword">while</span> (!st.isEmpty() || p!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</div><div class="line">            System.out.print(p.data + <span class="string">", "</span>);</div><div class="line">            st.push(p);</div><div class="line">            p = p.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!st.isEmpty())&#123;</div><div class="line">            p = st.pop();</div><div class="line">            <span class="comment">//栈中保存节点信息，为下一步p=p.right做准备，不可忽略</span></div><div class="line">            p = p.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>和前序遍历类似，不同在于从栈取出节点后输出节点信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 非递归实现中序遍历</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> node 访问节点</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midOrderStack</span><span class="params">(Node node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&lt;T&gt;&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Node&lt;T&gt; p = node;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!st.isEmpty() || p!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</div><div class="line">            st.push(p);</div><div class="line">            p = p.left;</div><div class="line">            <span class="comment">//一直遍历到左子树最左边，同时保存节点至栈</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!st.empty())&#123;</div><div class="line">            p = st.pop();</div><div class="line">            System.out.print(p.data + <span class="string">", "</span>);</div><div class="line">            p = p.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 非递归实现后序遍历（一）</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> node 节点</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrderStack1</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&lt;T&gt;&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Node&lt;T&gt; curN = node;<span class="comment">//当前访问节点</span></div><div class="line">    Node&lt;T&gt; lastN = <span class="keyword">null</span>;<span class="comment">//上次访问节点</span></div><div class="line">    <span class="keyword">while</span> (curN != <span class="keyword">null</span>)&#123;</div><div class="line">        st.push(curN);</div><div class="line">        curN = curN.left;</div><div class="line">        <span class="comment">//将curNode移到左子树最下边</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!st.isEmpty())&#123;</div><div class="line">        curN = st.pop();</div><div class="line">        <span class="keyword">if</span> (curN.right == <span class="keyword">null</span> || curN.right == lastN)&#123;</div><div class="line">            <span class="comment">//一个根节点被访问的条件是：无右子树或右子树已被访问过</span></div><div class="line">            System.out.print(curN.data + <span class="string">", "</span>);</div><div class="line">            lastN = curN;</div><div class="line">            <span class="comment">//修改最近被访问的节点</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            st.push(curN);<span class="comment">//根节点再次入栈</span></div><div class="line">            curN = curN.right;</div><div class="line">            <span class="keyword">while</span> (curN != <span class="keyword">null</span>)&#123;</div><div class="line">                st.push(curN);</div><div class="line">                curN = curN.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 使用队列实现层序遍历</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> node 访问节点</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeByQueue</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    LinkedList&lt;Node&lt;T&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    Node&lt;T&gt; p = <span class="keyword">null</span>;</div><div class="line">    queue.offer(node);</div><div class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">        p = queue.poll();</div><div class="line">        System.out.print(p.data + <span class="string">"-&gt;"</span>);</div><div class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</div><div class="line">            queue.offer(p.left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</div><div class="line">            queue.offer(p.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之初级排序]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>尽管实际中我们可以使用标准库中的函数完成排序而不需要自己实现，学习排序仍有很强的实际意义。<br><a id="more"></a></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。<br>当数据规模小到一定程度时，可以使用插入排序进行优化</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最好情况：数组有序，每插入一个元素，只需要比较前一个元素，时间复杂度为<code>O(N)</code></li>
<li>最坏情况：插入第N个元素，要考虑前<code>N - 1</code>个元素，比较次数为<code>1+2+3+..+n-1</code>，即<code>N^2/2</code>，时间复杂度<code>O(N^2)</code></li>
<li>平均情况：<code>O(N^2)</code></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] data)</span> </span>&#123;</div><div class="line">        sort(data, data.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] data, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    Comparable key;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        key = data[i];</div><div class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = data[j].compareTo(key);</div><div class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) data[j + <span class="number">1</span>] = data[j];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        data[j + <span class="number">1</span>] = key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之树（二）]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树（AVL）是一种改进后的二叉树，它每个结点的左子树和右子树的高度最多相差1。它的关键之处在于，插入和删除节点时通过旋转保持平衡。<br><a id="more"></a></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>插入操作时间复杂度为<strong>O(logn)</strong>，不会出现二叉查找树的最坏情况。</p>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><pre><code>N(h) = N(h-1) + N(h-2) + 1
N(h) = N(h-1) + N(h-1) + 1 = 2N(h-1) + 1
N(h)=O(2h)=&gt;h=logn≈O(logn)
</code></pre><ul>
<li>N(h-1) 代表高度为h-1的左子树的最小结点数</li>
<li>N(h-2) 代表高度为h-2的右子树的最小结点数</li>
<li>1 代表当前结点(根)。</li>
</ul>
<h2 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h2><h3 id="左左单旋转（LL）型"><a href="#左左单旋转（LL）型" class="headerlink" title="左左单旋转（LL）型"></a>左左单旋转（LL）型</h3><p>在平衡二叉树的左子树的左子树插入一个节点，导致平衡二叉树失衡，这就是LL情形此时需要进行右旋，使其恢复平衡。<br><img src="/2018/01/14/数据结构与算法之树（二）/Java数据结构与算法之树（二）/LL.png" alt="LL">  </p>
<p>代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* LL型 进行右旋操作</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 失衡的节点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 新的根节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">leftLeftRotate</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="comment">//声明一个newnode指向失衡节点的左节点</span></div><div class="line">    Node&lt;T&gt; newNode = node.left;</div><div class="line">    <span class="comment">//newnode的右节点变为失衡节点的左节点</span></div><div class="line">    node.left = newNode.right;</div><div class="line">    <span class="comment">//失衡节点成为新节点的右节点</span></div><div class="line">    newNode.right = node;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="右右单旋转（RR）型"><a href="#右右单旋转（RR）型" class="headerlink" title="右右单旋转（RR）型"></a>右右单旋转（RR）型</h3><p>同LL型相反，在平衡二叉树的右子树的右子树插入节点，失衡，此时进行左旋操作使其恢复平衡。<br><img src="/2018/01/14/数据结构与算法之树（二）/Java数据结构与算法之树（二）/RR.png" alt="RR"></p>
<p>代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* RR型  进行左旋操作</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 失衡节点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 新的根节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">rightRightRotate</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    Node&lt;T&gt; newNode = node.right;</div><div class="line">    node.right = newNode.left;</div><div class="line">    newNode.left = node;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="左右双选转型（LR）"><a href="#左右双选转型（LR）" class="headerlink" title="左右双选转型（LR）"></a>左右双选转型（LR）</h3><p>这种情况是在左子树的右子树插入节点造成失衡，这是需要先进行一次左旋转，再进行一次右旋转使其恢复平衡。<br><img src="/2018/01/14/数据结构与算法之树（二）/Java数据结构与算法之树（二）/LR.png" alt="LR">  </p>
<p>实现代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* LR型  失衡点的左子树进行左旋， 新的根节点再进行右旋</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 根节点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 新的根节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">leftRightRotate</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    node.left = rightRightRotate(node.left);</div><div class="line">    <span class="keyword">return</span> leftLeftRotate(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="右左双旋转型（RL）"><a href="#右左双旋转型（RL）" class="headerlink" title="右左双旋转型（RL）"></a>右左双旋转型（RL）</h3><p>理解了左右双旋，这里的实现也是同样的道理<br><img src="/2018/01/14/数据结构与算法之树（二）/Java数据结构与算法之树（二）/RL.png" alt="RL"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* RL型 失衡节点的右子树先进行右旋 新根节点左旋</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 根节点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 新的根节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">rightLeftRotate</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    node.right = leftLeftRotate(node.right);</div><div class="line">    <span class="keyword">return</span> rightRightRotate(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AVL树的插入"><a href="#AVL树的插入" class="headerlink" title="AVL树的插入"></a>AVL树的插入</h2><p>首先要判断插入节点是否平衡，需要计算节点的高度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 以node为根节点的树的高度</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 根节点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> node的高度</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h1, h2;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        h1 = deep(node.left);</div><div class="line">        h2 = deep(node.right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (h1 &gt; h2 ? h1 : h2) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 插入数据</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> data</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">    root = insert(data, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">insert</span><span class="params">(T data, Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) node = <span class="keyword">new</span> Node&lt;&gt;(data);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data.compareTo(node.data) &lt; <span class="number">0</span>) &#123;</div><div class="line">        node.left = insert(data, node.left);</div><div class="line">        <span class="keyword">if</span> (deep(node.left) - deep(node.right) == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (data.compareTo(node.left.data) &lt; <span class="number">0</span>)<span class="comment">//左子树的左节点，进行右旋操作</span></div><div class="line">                node = leftLeftRotate(node);</div><div class="line">            <span class="keyword">else</span> node = leftRightRotate(node);<span class="comment">//左子树的右节点 进行左旋</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        node.right = insert(data, node.right);</div><div class="line">        <span class="keyword">if</span> (deep(node.right) - deep(node.left) == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (data.compareTo(node.right.data) &lt; <span class="number">0</span>)<span class="comment">//右子树的左节点 先右旋后左旋</span></div><div class="line">                node = rightLeftRotate(node);</div><div class="line">            <span class="keyword">else</span> node = rightRightRotate(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断AVL树是否平衡"><a href="#判断AVL树是否平衡" class="headerlink" title="判断AVL树是否平衡"></a>判断AVL树是否平衡</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced</span><span class="params">()</span> </span>&#123;</div><div class="line">    getDepth(root);</div><div class="line">    <span class="keyword">return</span> isBalanced;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Node&lt;T&gt; root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = getDepth(root.left);</div><div class="line">    <span class="keyword">int</span> right = getDepth(root.right);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</div><div class="line">        isBalanced = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> right &gt; left ? right + <span class="number">1</span> : left + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/javazejian/article/details/53892797" target="_blank" rel="external">java数据结构与算法之平衡二叉树(AVL树)的设计与实现</a></li>
<li>《算法（第四版）》</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之树（一）]]></title>
      <url>/2018/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。<br><a id="more"></a></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点</li>
<li>具有n个结点的完全二叉树的深度为log2(n+1)</li>
<li>给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，<code>h(n)=C(2*n, n)/(n+1)</code></li>
</ol>
<h2 id="完全二叉树和满二叉树"><a href="#完全二叉树和满二叉树" class="headerlink" title="完全二叉树和满二叉树"></a>完全二叉树和满二叉树</h2><p>完全二叉树：完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p>
<p><img src="/2018/01/13/数据结构与算法之树（一）/Java数据结构与算法之树（一）/Tree1.png" alt="shu"></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>又称为是二叉排序树（Binary Sort Tree）或二叉搜索树<br>性质：对二叉查找树进行<strong>中序遍历</strong>，即可得到<strong>有序</strong>的数列  </p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>同二分查找一样，插入和查找的时间复杂度均为<strong>O(logn)</strong>，但是在最坏的情况下仍然会有<strong>O(n)</strong>的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。</p>
<h3 id="二叉查找树的创建与插入"><a href="#二叉查找树的创建与插入" class="headerlink" title="二叉查找树的创建与插入"></a>二叉查找树的创建与插入</h3><p>插入（递归实现）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> T data;<span class="comment">//节点数据</span></div><div class="line">        <span class="keyword">private</span> Node&lt;T&gt; left;<span class="comment">//左子节点</span></div><div class="line">        <span class="keyword">private</span> Node&lt;T&gt; right;<span class="comment">//右子节点</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; left, Node&lt;T&gt; right)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">            <span class="keyword">this</span>.left = left;</div><div class="line">            <span class="keyword">this</span>.right = right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node&lt;T&gt; root;<span class="comment">//根节点</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        root = insert(data, root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">insert</span><span class="params">(T data, Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(data);</div><div class="line">        <span class="keyword">int</span> com = data.compareTo(node.data);</div><div class="line"></div><div class="line">        <span class="comment">//插入数据小于当前节点数据，数据存放到到当前节点的左节点，否则存放到右节点</span></div><div class="line">        <span class="keyword">if</span> (com &lt; <span class="number">0</span>) node.left = insert(data, node.left);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (com &gt; <span class="number">0</span>) node.right = insert(data, node.right);</div><div class="line">        <span class="keyword">else</span> node.data = data;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        midPrint(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//中序遍历输出</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midPrint</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        midPrint(node.left);</div><div class="line">        System.out.println(node.data);</div><div class="line">        midPrint(node.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二叉查找树的遍历"><a href="#二叉查找树的遍历" class="headerlink" title="二叉查找树的遍历"></a>二叉查找树的遍历</h3><p>二叉查找树同其他二叉树一样，具有三种基本的遍历方式：前序遍历，中序遍历，后序遍历。  </p>
<p>前序遍历：访问根结点-&gt;访问左子树-&gt;访问右子树<br>中序遍历：访问左子树-&gt;访问根结点-&gt;访问右子树<br>后序遍历：访问左子树-&gt;访问右子树-&gt;访问根节点</p>
<p>使用递归实现三种遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prePrint</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    System.out.println(node.data);</div><div class="line">    prePrint(node.left);</div><div class="line">    prePrint(node.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midPrint</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    midPrint(node.left);</div><div class="line">    System.out.println(node.data);</div><div class="line">    midPrint(node.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//后序遍历</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">laPrint</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    laPrint(node.left);</div><div class="line">    laPrint(node.right);</div><div class="line">    System.out.println(node.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="返回树的深度"><a href="#返回树的深度" class="headerlink" title="返回树的深度"></a>返回树的深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deepTree</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> leftd, rightd;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        leftd = deepTree(node.left);</div><div class="line">        rightd = deepTree(node.right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (leftd &gt; rightd ? leftd : rightd) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除节点分为三种情况：  </p>
<ol>
<li>删除叶子节点</li>
<li>删除有一个孩子的节点</li>
<li>删除有两个孩子的节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//st 树的根节点，pt st的双亲</span></div><div class="line">    Node&lt;T&gt; st = root, pt = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//首先查找到要删除的节点</span></div><div class="line">    <span class="keyword">while</span> (st != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> temp = data.compareTo(st.data);</div><div class="line">        <span class="comment">//小于节点数据，向左查找</span></div><div class="line">        <span class="comment">//否则向右查找，找到退出循环</span></div><div class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</div><div class="line">            pt = st;</div><div class="line">            st = st.left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</div><div class="line">            pt = st;</div><div class="line">            st = st.right;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没有找到删除节点</span></div><div class="line">    <span class="keyword">if</span> (st == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (st.left == <span class="keyword">null</span> &amp;&amp; st.right == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//删除的节点为叶子节点</span></div><div class="line">        <span class="keyword">if</span> (st == root) root = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pt.left == st) pt.left = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">else</span> pt.right = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st.left == <span class="keyword">null</span> || st.right == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//单叶节点</span></div><div class="line">        <span class="keyword">if</span> (st == root) &#123;</div><div class="line">            <span class="keyword">if</span> (st.left == <span class="keyword">null</span>) root = st.right;</div><div class="line">            <span class="keyword">else</span> root = st.left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pt.left == st) &#123;</div><div class="line">            <span class="keyword">if</span> (st.left == <span class="keyword">null</span>) pt.left = st.right;</div><div class="line">            <span class="keyword">else</span> pt.left = st.left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pt.right == st) &#123;</div><div class="line">            <span class="keyword">if</span> (st.left == <span class="keyword">null</span>) pt.right = st.right;</div><div class="line">            <span class="keyword">else</span> pt.right = st.left;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//双叶节点</span></div><div class="line">        Node&lt;T&gt; s1 = st, s2 = st.left;</div><div class="line">        <span class="keyword">while</span> (s2.right != <span class="keyword">null</span>) &#123;</div><div class="line">            s1 = s2;</div><div class="line">            s2 = s2.right;</div><div class="line">        &#125;</div><div class="line">        st.data = s2.data;</div><div class="line">        <span class="keyword">if</span> (s1 == st) st.left = s2.left;</div><div class="line">        <span class="keyword">else</span> s1.right = s2.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之栈与队列]]></title>
      <url>/2018/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>栈是一种特殊的<strong>线性表</strong>。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。<br><a id="more"></a></p>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><ol>
<li>后进先出（rear In front Out），简称为<strong>LIFO</strong></li>
<li>限定只能在栈顶进行插入和删除操作。</li>
<li>n个数依次入栈，则出栈方式共有<code>C（2n,n）/(n+1)</code>种</li>
</ol>
<h3 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 基于链表的栈的实现</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//使用内部类创建节点</span></div><div class="line">        <span class="keyword">private</span> T data;</div><div class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node&lt;T&gt; root;<span class="comment">//栈顶指针</span></div><div class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//栈容量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T data)</span> </span>&#123; <span class="comment">//入栈</span></div><div class="line">        <span class="comment">//另一种描述</span></div><div class="line">        Node&lt;T&gt; oldRoot = root;</div><div class="line">        root = <span class="keyword">new</span> Node&lt;T&gt;(data);</div><div class="line">        root.next = oldRoot;</div><div class="line">        top++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*public void push(T data)&#123;</span></div><div class="line"><span class="comment">        root = new Node&lt;T&gt;(data, root);</span></div><div class="line"><span class="comment">        top ++;</span></div><div class="line"><span class="comment">    &#125;*/</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></div><div class="line">        <span class="keyword">if</span> (top &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T getData = root.getData();</div><div class="line">        root = root.next;</div><div class="line">        top--;</div><div class="line">        <span class="keyword">return</span> getData;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123; <span class="comment">//返回栈顶元素</span></div><div class="line">        <span class="keyword">return</span> root.getData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">//判断是否为空栈</span></div><div class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="comment">//清空栈</span></div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">        top = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><ol>
<li>数值转换</li>
<li>表达式求值</li>
<li>浏览器历史纪录</li>
<li>解析xml/json等</li>
</ol>
<h4 id="使用栈进行十进制转任意进制"><a href="#使用栈进行十进制转任意进制" class="headerlink" title="使用栈进行十进制转任意进制"></a>使用栈进行十进制转任意进制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 十进制转任意进制（最高16）</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> dec </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> hex</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 字符串形式的转换结果</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hex</span><span class="params">(<span class="keyword">int</span> dec, <span class="keyword">int</span> hex)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stackHex = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    StringBuilder strHex = <span class="keyword">new</span> StringBuilder();</div><div class="line">    String str = <span class="string">"0123456789ABCDE"</span>;</div><div class="line">    <span class="keyword">int</span> rem = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (dec &gt; <span class="number">0</span>) &#123;</div><div class="line">        rem = dec % hex;</div><div class="line">        dec /= hex;</div><div class="line">        stackHex.push(rem);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stackHex.isEmpty())</div><div class="line">        strHex.append(str.charAt(stackHex.pop()));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> strHex.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种特殊的<strong>线性表</strong>，只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。</p>
<h3 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h3><ol>
<li>先进先出（First In First Out），<strong>FIFO</strong></li>
</ol>
<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 利用链表实现队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//队列节点</span></div><div class="line">        <span class="keyword">private</span> T data;</div><div class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node&lt;T&gt; front; <span class="comment">//队首指针</span></div><div class="line">    <span class="keyword">private</span> Node&lt;T&gt; rear; <span class="comment">//队尾指针</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//队列容量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(T data)</span> </span>&#123; <span class="comment">//入队</span></div><div class="line">        Node&lt;T&gt; oldrear = rear;</div><div class="line">        rear = <span class="keyword">new</span> Node&lt;&gt;(data);</div><div class="line">        rear.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (isEmpty()) front = rear;</div><div class="line">        <span class="keyword">else</span> oldrear.next = rear;</div><div class="line">        n++;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Dequeue</span><span class="params">()</span> </span>&#123; <span class="comment">//出队</span></div><div class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T data = front.data;</div><div class="line">        front = front.next;</div><div class="line">        n--;</div><div class="line">        <span class="keyword">if</span> (isEmpty()) rear = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123; <span class="comment">//查看队首元素</span></div><div class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> front.data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">//判断队列是否为空</span></div><div class="line">        <span class="keyword">return</span> front == <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年度小结]]></title>
      <url>/2017/12/31/2017%E5%B9%B4%E5%BA%A6%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;2017年算是颇有收获的一年。<br><a id="more"></a><br>&emsp;&emsp;确定了自己毕业后要从事的方向，跟自己的专业没有太大关系，所以基本要靠自学了。想想或许这也不是什么坏事，可以按照自己喜欢的方式学习，还能锻炼学习能力。</p>
<h2 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h2><p>&emsp;&emsp;这一年里，基于兴趣学习了几门流行的编程语言，学习了前端的一些基本知识。上半年开始了自己的自学之路，由于之前没有任何编程基础，同时本专业还有一些任务，靠挤时间花了大半个学期算是学完了Java的基础部分。下半年已经确定进入互联网搬砖，开始有计划的学习。虽然学习完了数据结构，但是自己的计划没有完全完成。总结起来，一是前期的学习比较杂乱，几乎是在同时学习前端+python+javaweb+其他，之后发现这样的学习效率并不高，于是将主要精力集中在数据结构，才能基本完成计划。二是还在兼顾专业课，现在觉得不应该在专业课下太多的功夫，说到底还是自己缺乏背水一战的决心。</p>
<h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><p>&emsp;&emsp;不久前接触到了几个不错的个人博客，后来偶然了解到可以用Hexo+github搭建个人博客，出于折腾心理自己也搭建了一个。看过很多大神分享的面经，他们都有一个共同的习惯：总结。这也是我搭建博客的一个原因，静下心来写写总结，记录下自己的学习，生活，沉淀自己。</p>
<h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><p>&emsp;&emsp;不知什么时候开始喜欢上看电影。作为第八艺术，一部优秀的电影足以带给你很多启示。高考后看完了很多经典电影。像《肖申克的救赎》，《霸王别姬》，《蝙蝠侠：黑暗骑士》。。。慢慢的意识到，虽然自己没有写影评的文笔，但应该记录下看过的电影。于是从下半年开始记录自己看过的电影。</p>
<p><img src="/2017/12/31/2017年度小结/movies.png" alt="movies"></p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>&emsp;&emsp;不久前入正了《巫师3：狂猎》，这是我第一款入正的游戏，也是我游戏时间最长的一款游戏，2017年的娱乐时间基本给了它。盗版已经快要玩通了，现在入正来表示对CD Projekt RED的支持，毕竟以后难得再遇到这样优秀的游戏。</p>
<h2 id="关于感情"><a href="#关于感情" class="headerlink" title="关于感情"></a>关于感情</h2><center>不存在的</center>
]]></content>
      
        <categories>
            
            <category> 年度小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 年度小结 </tag>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下安装Ubuntu 16.04双系统]]></title>
      <url>/2017/12/29/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu-16-04%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>准备体验一下Linux，就在原有的Windows10系统下，安装Ubuntu官方会长期提供支持的最新的Ubuntu 16.04。记录一下自己的安装过程。<br><a id="more"></a></p>
<h1 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h1><ol>
<li><p>准备工具<br>U盘，Ubuntu 16.04 LTS镜像，<a href="http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows" target="_blank" rel="external">启动U盘制作软件</a></p>
</li>
<li><p>分区<br>分区我用的是<a href="http://www.diskgenius.cn/download.php" target="_blank" rel="external">DiskGenius</a>这款软件，将自己的一个盘分出了50G的空白空间。之后点击这空白空间，新建分区。</p>
</li>
<li><p>制作U盘启动盘<br>运行下载好的 rufus 这个软件，载入下载的Ubuntu镜像，之后点击开始，一路点击确定，等待一会，写入成功。</p>
</li>
</ol>
<p>成功后如下图<br><img src="/2017/12/29/Windows下安装Ubuntu-16-04双系统/2017.png" alt="图片"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>从U盘启动<br>U盘插在电脑上，选择启动方式为U盘启动，（设置U盘启动可以进入BIOS）</li>
<li>安装Ubuntu<br>选择了U盘启动后，会出现如下“欢迎”界面，选择中文后，点击“安装Ubuntu”;</li>
<li>选择安装类型<br>最好选择“其他选项”</li>
<li><p>安装位置和磁盘分区<br>这是很关键的一步。<br>双击前面分好的空白分区，分配分区<br>网上的建议分区大小</p>
<pre><code>/boot - 200 MB ； 实际需求大约 100 ~ 200MB，建议分配 200 或者 300 MB。
/ - 15-20 GB ； 15-20 GB 对于大多数用户来说是一个比较合适的取值。
/home - [不定] ； 通常用于存放用户数据，下载的文件和媒体文件。在桌面系统中，/home 通常是最大的文件系统。(个人建议: 多多益善)
swap - [不定] ；内存（大于 1024 MB），可以分配较少的空间甚至不需要swap 分区。
</code></pre><p> 装双系统，<code>/boot</code> 选择”逻辑分区”就行了</p>
<p> “/boot” 分区: “逻辑分区”、”空间起始位置”、”Ext4日志文件系统”、挂载点”/boot”<br> ”/“分区： ”逻辑分区“、”空间起始位置“、”Ext4日志文件系统“、挂载点”/“<br> ”/home“分区：”逻辑分区“、”空间起始位置“、”Ext2文件系统“、挂载点”/home“<br> ”交换空间“：”逻辑分区“、”空间起始位置“、”交换空间“</p>
<p> “安装启动引导器的设备”选择/boot对应的分区<br> 检查无误之后，点击“现在安装”</p>
</li>
<li><p>检查分区</p>
</li>
<li>选择区域，键盘</li>
<li>设置用户名及密码</li>
<li>安装，重启</li>
</ol>
<p>安装成功后我的机子算是三系统共存，Windows10 + Ubuntu + Phoenix OS，选择不同的系统方法也很简单，开机之后屏幕左下提示选择启动方式，这时按下“Esc”按钮，就会进入启动管理，之后选择要启动的系统，进入即可。<br><img src="/2017/12/29/Windows下安装Ubuntu-16-04双系统/201728.jpg" alt="图"></p>
<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="https://www.cnblogs.com/Duane/p/5424218.html" target="_blank" rel="external">Windows下安装Ubuntu 16.04双系统</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 双系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/2017/12/28/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><center>Markdown语法</center></h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code>`# 一级标题`
`## 二级标题`
</code></pre><a id="more"></a>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><pre><code>*斜体文本* 
**粗体文本**
~~在文字上添加删除线~~
</code></pre><h3 id="链接网站"><a href="#链接网站" class="headerlink" title="链接网站"></a>链接网站</h3><pre><code>[链接名称](http://链接网址)
&lt;http://链接网址&gt;
[Google][1]   [1]:http://www.google.com/
</code></pre><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript syntax highlighting"</span>;</div><div class="line">alert(s);</div></pre></td></tr></table></figure>
</code></pre><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><pre><code>![图片名称](http://图片网址)

也可以使用 HTML 的图片语法来自定义图片的宽高大小
[站外图片上传中……(3)]
</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>- 列表文本前使用 [减号+空格]
+ 列表文本前使用 [加号+空格]
* 列表文本前使用 [星号+空格]
1. 列表前使用 [数字+空格]
2. 我们会自动帮你添加数字
7. 不用担心数字不对
</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 引用文本前使用 [大于号+空格]
</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><pre><code>如果另起一行，只需在当前行结尾加 2 个空格
如果是要起一个新段落，只需要空出一行即可。
分隔符  ---
</code></pre><h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><h3 id="使用HTML元素"><a href="#使用HTML元素" class="headerlink" title="使用HTML元素"></a>使用HTML元素</h3><p>如<code>图片居中：&lt;center&gt; &lt;/center&gt;</code></p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><pre><code>$$ x = {-b pm sqrt{b^2-4ac} over 2a} $$
</code></pre><p>更详细说明<br><a href="https://link.jianshu.com/?t=http://wowubuntu.com/markdown/index.html#editor" target="_blank" rel="external">Markdown 语法说明</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo美化]]></title>
      <url>/2017/12/25/Hexo%E7%BE%8E%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="主题语言设置"><a href="#主题语言设置" class="headerlink" title="主题语言设置"></a>主题语言设置</h2><p>首先修改hexo根文件夹下的<br><code>F:\hexo\_config.yml</code>修改为<code>language: zh-CN   #网站使用的语言</code>，然后修改主题文件的语言<br>菜单项显示文本：设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。<a id="more"></a>这些翻译文本放置在 <strong>NexT</strong> 主题目录下的 <code>languages/{language}.yml</code> （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 <code>something</code>。那么就需要修改简体中文对应的翻译文件 <code>languages/zh-Hans.yml</code>，在 <code>menu</code> 字段下添加一项:</p>
<pre><code>menu:
    home: 首页
    archives: 归档
    categories: 分类
    tags: 标签
    about: 关于
    search: 搜索
    commonweal: 公益404
    something: 有料
</code></pre><h2 id="设置favicon："><a href="#设置favicon：" class="headerlink" title="设置favicon："></a>设置favicon：</h2><p>favicon的全称Favorites Icon，即地址栏左侧的图标.<br>有个<a href="http://www.atool.org/ico.php" target="_blank" rel="external">在线工具</a>可以上传自己的图片去生成指定规格的<code>favicon.ico</code>文件。<br>打开主题配置文件<code>_config.yml</code>可以看到favicon的配置信息：</p>
<pre><code># Put your favicon.ico into `hexo-site/source/` directory.
favicon: /favicon.ico  
</code></pre><h2 id="添加标签与分类"><a href="#添加标签与分类" class="headerlink" title="添加标签与分类"></a>添加标签与分类</h2><p>首先，主题配置文件中，在<code>menu</code>项下，要把<code>tags</code>页打开</p>
<pre><code>menu:
  home: /
  categories: /categories
  #about: /about
  archives: /archives
  tags: /tags    //确保标签页已打开
  #schedule: /schedule     
  #commonweal: /404.html  
</code></pre><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><h3 id="一种方法"><a href="#一种方法" class="headerlink" title="一种方法"></a>一种方法</h3><pre><code>![图片名](链接)
</code></pre><h3 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h3><ol>
<li>主页配置文件<code>_config.yml</code>里<code>post_asset_folder:</code>这个选项设置为<code>true</code></li>
<li>在hexo目录执行 <code>npm install hexo-asset-image --save</code>，下载安装一个可以上传本地图片的插件</li>
<li>之后运行<code>hexo n &quot;xxxx&quot;</code>生成md文章，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</li>
<li><p>在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在<code>xxxx.md</code>中按照markdown的格式引入图片：</p>
<pre><code>![你想输入的替代文字](xxxx/图片名.jpg)
</code></pre></li>
<li><p>检查，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code></p>
</li>
</ol>
<h2 id="添加标签与分类-1"><a href="#添加标签与分类-1" class="headerlink" title="添加标签与分类"></a>添加标签与分类</h2><pre><code>hexo new page tags
</code></pre><p>确认站点配置文件里有<code>tag_dir: tags</code><br>确认主题配置文件里有<code>tags: /tags</code><br>编辑<code>source/tags/index.md</code></p>
<pre><code>title: tags
date: 
type: &quot;tags&quot;
</code></pre><h3 id="添加多个标签"><a href="#添加多个标签" class="headerlink" title="添加多个标签"></a>添加多个标签</h3><pre><code>tags: [标签1,标签2,标签3]
</code></pre><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><pre><code>hexo new page categories
</code></pre><p>确认站点配置文件里<code>category_dir: categories</code><br>确认主题配置文件里有<code>categories: /categories</code><br>编辑站点的<code>source/categories/index.md</code> </p>
<pre><code>title: categories
date: 
type: &quot;categories&quot;
</code></pre><h3 id="文章自动添加categories"><a href="#文章自动添加categories" class="headerlink" title="文章自动添加categories"></a>文章自动添加<code>categories</code></h3><p>在<code>scaffold</code>里有<code>post.md</code>，这是创建post的模板，添加相应的配置</p>
<h2 id="菜单栏控制"><a href="#菜单栏控制" class="headerlink" title="菜单栏控制"></a>菜单栏控制</h2><p>修改主题配置文件</p>
<pre><code># ------------------------------------------------------
# Menu Settings
# ------------------------------------------------------

# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)
menu:
  home: /
  #categories: /categories
  about: /about
  archives: /archives
  tags: /tags
  #commonweal: /404.html
</code></pre><h2 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h2><p>在主题配置文件的<code>sidebar</code>字段，此处我直接设置为侧栏一直显示，而且显示在右边：</p>
<pre><code>sidebar:
  # Sidebar Position, available value: left | right
  position: left
  #position: right

  # Sidebar Display, available value:
  #  - post    expand on posts automatically. Default.
  #  - always  expand for all pages automatically
  #  - hide    expand only when click on the sidebar toggle icon.
  #  - remove  Totally remove sidebar including sidebar toggler.
  #display: post
  display: always
  #display: hide
  #display: remove
</code></pre><h2 id="设置头像和作者名称"><a href="#设置头像和作者名称" class="headerlink" title="设置头像和作者名称"></a>设置头像和作者名称</h2><p>在站点配置文件中，新加一个字段<code>avatar</code>，值就是头像的连接地址，将<code>avatar.png</code>放到本地目录<code>hexo\source\images</code>中；作者名称直接设置站点配置文件中<code>author</code>字段的值：</p>
<pre><code># Site
title: Linsh-何乐不为~
subtitle:
description:
author: Linshuhe
avatar: /images/avatar.png
language: zh-Hans
timezone:
</code></pre><h2 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h2><h3 id="在文章使用-lt-more-gt-手动设置"><a href="#在文章使用-lt-more-gt-手动设置" class="headerlink" title="在文章使用&lt;!--more--&gt;手动设置"></a>在文章使用<code>&lt;!--more--&gt;</code>手动设置</h3><p>根据文章的内容，自己在合适的位置添加 <code>&lt; !--more--&gt;</code> 标签，使用灵活，也是Hexo推荐的方法。<br><img src="https://upload-images.jianshu.io/upload_images/2352140-ec93f0ac69d07b21.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/635" alt="图片"></p>
<h3 id="在文章中的front-matter中添加description，并提供文章摘录"><a href="#在文章中的front-matter中添加description，并提供文章摘录" class="headerlink" title="在文章中的front-matter中添加description，并提供文章摘录"></a>在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘录</h3><p>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。<br><img src="https://upload-images.jianshu.io/upload_images/2352140-67c6e1edb5695035.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/630" alt="图片2"></p>
<h3 id="自动形成摘要，在主题配置文件中添加"><a href="#自动形成摘要，在主题配置文件中添加" class="headerlink" title="自动形成摘要，在主题配置文件中添加"></a>自动形成摘要，在<strong>主题配置</strong>文件中添加</h3><p>默认截取的长度为 150 字符，可以根据需要自行设定</p>
<pre><code>auto_excerpt:
  enable: true
  length: 150
</code></pre><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ol>
<li><a href="http://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="external">Hexo个人免费博客(三) next主题、评论、阅读量统计和站内搜索</a></li>
<li><a href="https://www.jianshu.com/p/78c218f9d1e7" target="_blank" rel="external">Hexo-设置阅读全文</a></li>
<li><a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">hexo生成博文插入图片</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/21/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
