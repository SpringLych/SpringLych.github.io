<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2018%2F02%2F20%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Github在新疆被屏蔽，上一次使用Hexo发布新博客失败，这次试试能不能发表成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之排序（一）]]></title>
    <url>%2F2018%2F01%2F14%2FJava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序尽管实际中我们可以使用标准库中的函数完成排序而不需要自己实现，学习排序仍有很强的实际意义。 插入排序插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 时间复杂度 最好情况：数组有序，每插入一个元素，只需要比较前一个元素，时间复杂度为O(N) 最坏情况：插入第N个元素，要考虑前N - 1个元素，比较次数为1+2+3+..+n-1，即N^2/2，时间复杂度O(N^2) 代码实现1234567891011121314151617public void sort(Comparable[] data) &#123; sort(data, data.length); &#125;private void sort(Comparable[] data, int len) &#123; int i, j; Comparable key; for (i = 1; i &lt; len; i++) &#123; key = data[i]; for (j = i - 1; j &gt;= 0; j--) &#123; int com = data[j].compareTo(key); if (com &gt; 0) data[j + 1] = data[j]; else break; &#125; data[j + 1] = key; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之树（二）]]></title>
    <url>%2F2018%2F01%2F14%2FJava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平衡二叉树平衡二叉树（AVL）是一种改进后的二叉树，它每个结点的左子树和右子树的高度最多相差1。它的关键之处在于，插入和删除节点时通过旋转保持平衡。 时间复杂度插入操作时间复杂度为O(logn)，不会出现二叉查找树的最坏情况。 推导过程N(h) = N(h-1) + N(h-2) + 1 N(h) = N(h-1) + N(h-1) + 1 = 2N(h-1) + 1 N(h)=O(2h)=&gt;h=logn≈O(logn) N(h-1) 代表高度为h-1的左子树的最小结点数 N(h-2) 代表高度为h-2的右子树的最小结点数 1 代表当前结点(根)。 AVL树的旋转左左单旋转（LL）型在平衡二叉树的左子树的左子树插入一个节点，导致平衡二叉树失衡，这就是LL情形此时需要进行右旋，使其恢复平衡。 代码实现123456789101112131415/*** LL型 进行右旋操作** @param node 失衡的节点* @return 新的根节点*/private Node&lt;T&gt; leftLeftRotate(Node&lt;T&gt; node) &#123; //声明一个newnode指向失衡节点的左节点 Node&lt;T&gt; newNode = node.left; //newnode的右节点变为失衡节点的左节点 node.left = newNode.right; //失衡节点成为新节点的右节点 newNode.right = node; return newNode;&#125; 右右单旋转（RR）型同LL型相反，在平衡二叉树的右子树的右子树插入节点，失衡，此时进行左旋操作使其恢复平衡。 代码实现123456789101112/*** RR型 进行左旋操作** @param node 失衡节点* @return 新的根节点*/private Node&lt;T&gt; rightRightRotate(Node&lt;T&gt; node) &#123; Node&lt;T&gt; newNode = node.right; node.right = newNode.left; newNode.left = node; return newNode;&#125; 左右双选转型（LR）这种情况是在左子树的右子树插入节点造成失衡，这是需要先进行一次左旋转，再进行一次右旋转使其恢复平衡。 实现代码12345678910/*** LR型 失衡点的左子树进行左旋， 新的根节点再进行右旋** @param node 根节点* @return 新的根节点*/private Node&lt;T&gt; leftRightRotate(Node&lt;T&gt; node) &#123; node.left = rightRightRotate(node.left); return leftLeftRotate(node);&#125; 右左双旋转型（RL）理解了左右双旋，这里的实现也是同样的道理12345678910/*** RL型 失衡节点的右子树先进行右旋 新根节点左旋** @param node 根节点* @return 新的根节点*/private Node&lt;T&gt; rightLeftRotate(Node&lt;T&gt; node) &#123; node.right = leftLeftRotate(node.right); return rightRightRotate(node);&#125; AVL树的插入首先要判断插入节点是否平衡，需要计算节点的高度 123456789101112131415/*** 以node为根节点的树的高度** @param node 根节点* @return node的高度*/private int deep(Node&lt;T&gt; node) &#123; int h1, h2; if (node == null) return 0; else &#123; h1 = deep(node.left); h2 = deep(node.right); &#125; return (h1 &gt; h2 ? h1 : h2) + 1;&#125; 插入12345678910111213141516171819202122232425262728/*** 插入数据** @param data*/public void insert(T data) &#123; root = insert(data, root);&#125;private Node&lt;T&gt; insert(T data, Node&lt;T&gt; node) &#123; if (node == null) node = new Node&lt;&gt;(data); else if (data.compareTo(node.data) &lt; 0) &#123; node.left = insert(data, node.left); if (deep(node.left) - deep(node.right) == 2) &#123; if (data.compareTo(node.left.data) &lt; 0)//左子树的左节点，进行右旋操作 node = leftLeftRotate(node); else node = leftRightRotate(node);//左子树的右节点 进行左旋 &#125; &#125; else &#123; node.right = insert(data, node.right); if (deep(node.right) - deep(node.left) == 2) &#123; if (data.compareTo(node.right.data) &lt; 0)//右子树的左节点 先右旋后左旋 node = rightLeftRotate(node); else node = rightRightRotate(node); &#125; &#125; return node;&#125; 判断AVL树是否平衡123456789101112131415161718private boolean isBalanced = true;public boolean IsBalanced() &#123; getDepth(root); return isBalanced;&#125;private int getDepth(Node&lt;T&gt; root) &#123; if (root == null) return 0; int left = getDepth(root.left); int right = getDepth(root.right); if (Math.abs(left - right) &gt; 1) &#123; isBalanced = false; &#125; return right &gt; left ? right + 1 : left + 1;&#125; 参考 java数据结构与算法之平衡二叉树(AVL树)的设计与实现 《算法（第四版）》]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之树（一）]]></title>
    <url>%2F2018%2F01%2F13%2FJava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉树定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。 二叉树的性质 深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点 具有n个结点的完全二叉树的深度为log2(n+1) 给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1) 完全二叉树和满二叉树完全二叉树：完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。 二叉查找树又称为是二叉排序树（Binary Sort Tree）或二叉搜索树性质：对二叉查找树进行中序遍历，即可得到有序的数列 时间复杂度同二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。 二叉查找树的创建与插入插入（递归实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class BST&lt;T extends Comparable&lt;T&gt;&gt; &#123; class Node&lt;T&gt; &#123; private T data;//节点数据 private Node&lt;T&gt; left;//左子节点 private Node&lt;T&gt; right;//右子节点 public Node(T data) &#123; this.data = data; &#125; private Node(T data, Node&lt;T&gt; left, Node&lt;T&gt; right) &#123; this.data = data; this.left = left; this.right = right; &#125; &#125; private Node&lt;T&gt; root;//根节点 public void insert(T data) &#123; root = insert(data, root); &#125; private Node&lt;T&gt; insert(T data, Node&lt;T&gt; node) &#123; if (node == null) return new Node&lt;&gt;(data); int com = data.compareTo(node.data); //插入数据小于当前节点数据，数据存放到到当前节点的左节点，否则存放到右节点 if (com &lt; 0) node.left = insert(data, node.left); else if (com &gt; 0) node.right = insert(data, node.right); else node.data = data; return node; &#125; public void print() &#123; midPrint(root); &#125; //中序遍历输出 private void midPrint(Node&lt;T&gt; node) &#123; if (node == null) return; midPrint(node.left); System.out.println(node.data); midPrint(node.right); &#125;&#125; 二叉查找树的遍历二叉查找树同其他二叉树一样，具有三种基本的遍历方式：前序遍历，中序遍历，后序遍历。 前序遍历：访问根结点-&gt;访问左子树-&gt;访问右子树中序遍历：访问左子树-&gt;访问根结点-&gt;访问右子树后序遍历：访问左子树-&gt;访问右子树-&gt;访问根节点 使用递归实现三种遍历1234567891011121314151617181920212223//前序遍历private void prePrint(Node&lt;T&gt; node)&#123; if (node == null) return; System.out.println(node.data); prePrint(node.left); prePrint(node.right);&#125;//中序遍历private void midPrint(Node&lt;T&gt; node) &#123; if (node == null) return; midPrint(node.left); System.out.println(node.data); midPrint(node.right);&#125;//后序遍历private void laPrint(Node&lt;T&gt; node)&#123; if (node == null) return; laPrint(node.left); laPrint(node.right); System.out.println(node.data);&#125; 返回树的深度123456789private int deepTree(Node&lt;T&gt; node) &#123; int leftd, rightd; if (node == null) return 0; else &#123; leftd = deepTree(node.left); rightd = deepTree(node.right); &#125; return (leftd &gt; rightd ? leftd : rightd) + 1;&#125; 删除操作删除节点分为三种情况： 删除叶子节点 删除有一个孩子的节点 删除有两个孩子的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean delete(T data) &#123; if (root == null) return false; //st 树的根节点，pt st的双亲 Node&lt;T&gt; st = root, pt = null; //首先查找到要删除的节点 while (st != null) &#123; int temp = data.compareTo(st.data); //小于节点数据，向左查找 //否则向右查找，找到退出循环 if (temp &lt; 0) &#123; pt = st; st = st.left; &#125; else if (temp &gt; 0) &#123; pt = st; st = st.right; &#125; else break; &#125; //没有找到删除节点 if (st == null) return false; if (st.left == null &amp;&amp; st.right == null) &#123; //删除的节点为叶子节点 if (st == root) root = null; else if (pt.left == st) pt.left = null; else pt.right = null; &#125; else if (st.left == null || st.right == null) &#123; //单叶节点 if (st == root) &#123; if (st.left == null) root = st.right; else root = st.left; &#125; else if (pt.left == st) &#123; if (st.left == null) pt.left = st.right; else pt.left = st.left; &#125; else if (pt.right == st) &#123; if (st.left == null) pt.right = st.right; else pt.right = st.left; &#125; &#125; else &#123; //双叶节点 Node&lt;T&gt; s1 = st, s2 = st.left; while (s2.right != null) &#123; s1 = s2; s2 = s2.right; &#125; st.data = s2.data; if (s1 == st) st.left = s2.left; else s1.right = s2.left; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之栈与队列]]></title>
    <url>%2F2018%2F01%2F06%2FJava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈栈的定义栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 栈的特点 后进先出（rear In front Out），简称为LIFO 限定只能在栈顶进行插入和删除操作。 n个数依次入栈，则出栈方式共有C（2n,n）/(n+1)种 栈的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** 基于链表的栈的实现*/public class Stack&lt;T&gt; &#123; class Node&lt;T&gt; &#123; //使用内部类创建节点 private T data; private Node&lt;T&gt; next; private Node(T data) &#123; this.data = data; &#125; private Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; private T getData() &#123; return data; &#125; &#125; Node&lt;T&gt; root;//栈顶指针 int top = -1;//栈容量 public void push(T data) &#123; //入栈 //另一种描述 Node&lt;T&gt; oldroot = root; root = new Node&lt;T&gt;(data); root.next = oldroot; top++; &#125; /*public void push(T data)&#123; root = new Node&lt;T&gt;(data, root); top ++; &#125;*/ public T pop() &#123; //出栈 if (top &lt;= -1) return null; T getData = root.getData(); root = root.next; top--; return getData; &#125; public T peek() &#123; //返回栈顶元素 return root.getData(); &#125; public boolean isEmpty() &#123; //判断是否为空栈 return top == -1; &#125; public void clear()&#123; //清空栈 root = null; top = -1; &#125;&#125; 栈的应用 数值转换 表达式求值 浏览器历史纪录 解析xml/json等 使用栈进行十进制转任意进制1234567891011121314151617181920212223/** * 十进制转任意进制（最高16） * * @param dec * @param hex * @return 字符串形式的转换结果 */public String hex(int dec, int hex) &#123; Stack&lt;Integer&gt; stackHex = new Stack&lt;&gt;(); StringBuilder strHex = new StringBuilder(); String str = "0123456789ABCDE"; int rem = 0; while (dec &gt; 0) &#123; rem = dec % hex; dec /= hex; stackHex.push(rem); &#125; while (!stackHex.isEmpty()) strHex.append(str.charAt(stackHex.pop())); return strHex.toString();&#125; 队列队列是一种特殊的线性表，只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。 队列的特点 先进先出（First In First Out），FIFO 队列的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 利用链表实现队列*/public class Queue&lt;T&gt; &#123; class Node&lt;T&gt; &#123; //队列节点 private T data; private Node&lt;T&gt; next; private Node(T data) &#123; this.data = data; &#125; &#125; private Node&lt;T&gt; front; //队首指针 private Node&lt;T&gt; rear; //队尾指针 private int n; //队列容量 public void Enqueue(T data) &#123; //入队 Node&lt;T&gt; oldrear = rear; rear = new Node&lt;&gt;(data); rear.next = null; if (isEmpty()) front = rear; else oldrear.next = rear; n++; &#125; public T Dequeue() &#123; //出队 if (isEmpty()) return null; T data = front.data; front = front.next; n--; if (isEmpty()) rear = null; return data; &#125; public T peek() &#123; //查看队首元素 if (isEmpty()) return null; return front.data; &#125; public boolean isEmpty() &#123; //判断队列是否为空 return front == null; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年度小结]]></title>
    <url>%2F2017%2F12%2F31%2F2017%E5%B9%B4%E5%BA%A6%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2017年算是颇有收获的一年。&emsp;&emsp;确定了自己毕业后要从事的方向，跟自己的专业没有太大关系，所以基本要靠自学了。想想或许这也不是什么坏事，可以按照自己喜欢的方式学习，还能锻炼学习能力。 关于学习&emsp;&emsp;这一年里，基于兴趣学习了几门流行的编程语言，学习了前端的一些基本知识。上半年开始了自己的自学之路，由于之前没有任何编程基础，同时本专业还有一些任务，靠挤时间花了大半个学期算是学完了Java的基础部分。下半年已经确定进入互联网搬砖，开始有计划的学习。虽然学习完了数据结构，但是自己的计划没有完全完成。总结起来，一是前期的学习比较杂乱，几乎是在同时学习前端+python+javaweb+其他，之后发现这样的学习效率并不高，于是将主要精力集中在数据结构，才能基本完成计划。二是还在兼顾专业课，现在觉得不应该在专业课下太多的功夫，说到底还是自己缺乏背水一战的决心。 个人博客&emsp;&emsp;不久前接触到了几个不错的个人博客，后来偶然了解到可以用Hexo+github搭建个人博客，出于折腾心理自己也搭建了一个。看过很多大神分享的面经，他们都有一个共同的习惯：总结。这也是我搭建博客的一个原因，静下心来写写总结，记录下自己的学习，生活，沉淀自己。 关于生活电影&emsp;&emsp;不知什么时候开始喜欢上看电影。作为第八艺术，一部优秀的电影足以带给你很多启示。高考后看完了很多经典电影。像《肖申克的救赎》，《霸王别姬》，《蝙蝠侠：黑暗骑士》。。。慢慢的意识到，虽然自己没有写影评的文笔，但应该记录下看过的电影。于是从下半年开始记录自己看过的电影。 游戏&emsp;&emsp;不久前入正了《巫师3：狂猎》，这是我第一款入正的游戏，也是我游戏时间最长的一款游戏，2017年的娱乐时间基本给了它。盗版已经快要玩通了，现在入正来表示对CD Projekt RED的支持，毕竟以后难得再遇到这样优秀的游戏。 关于感情不存在的]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>年度小结</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Ubuntu 16.04双系统]]></title>
    <url>%2F2017%2F12%2F29%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu-16-04%E5%8F%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[准备体验一下Linux，就在原有的Windows10系统下，安装Ubuntu官方会长期提供支持的最新的Ubuntu 16.04。记录一下自己的安装过程。 准备过程 准备工具U盘，Ubuntu 16.04 LTS镜像，启动U盘制作软件 分区分区我用的是DiskGenius这款软件，将自己的一个盘分出了50G的空白空间。之后点击这空白空间，新建分区。 制作U盘启动盘运行下载好的 rufus 这个软件，载入下载的Ubuntu镜像，之后点击开始，一路点击确定，等待一会，写入成功。 成功后如下图 安装 从U盘启动U盘插在电脑上，选择启动方式为U盘启动，（设置U盘启动可以进入BIOS） 安装Ubuntu选择了U盘启动后，会出现如下“欢迎”界面，选择中文后，点击“安装Ubuntu”; 选择安装类型最好选择“其他选项” 安装位置和磁盘分区这是很关键的一步。双击前面分好的空白分区，分配分区网上的建议分区大小 /boot - 200 MB ； 实际需求大约 100 ~ 200MB，建议分配 200 或者 300 MB。 / - 15-20 GB ； 15-20 GB 对于大多数用户来说是一个比较合适的取值。 /home - [不定] ； 通常用于存放用户数据，下载的文件和媒体文件。在桌面系统中，/home 通常是最大的文件系统。(个人建议: 多多益善) swap - [不定] ；内存（大于 1024 MB），可以分配较少的空间甚至不需要swap 分区。 装双系统，/boot 选择”逻辑分区”就行了 “/boot” 分区: “逻辑分区”、”空间起始位置”、”Ext4日志文件系统”、挂载点”/boot” ”/“分区： ”逻辑分区“、”空间起始位置“、”Ext4日志文件系统“、挂载点”/“ ”/home“分区：”逻辑分区“、”空间起始位置“、”Ext2文件系统“、挂载点”/home“ ”交换空间“：”逻辑分区“、”空间起始位置“、”交换空间“ “安装启动引导器的设备”选择/boot对应的分区 检查无误之后，点击“现在安装” 检查分区 选择区域，键盘 设置用户名及密码 安装，重启 安装成功后我的机子算是三系统共存，Windows10 + Ubuntu + Phoenix OS，选择不同的系统方法也很简单，开机之后屏幕左下提示选择启动方式，这时按下“Esc”按钮，就会进入启动管理，之后选择要启动的系统，进入即可。 参考来源Windows下安装Ubuntu 16.04双系统]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>双系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2017%2F12%2F28%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法基本语法标题`# 一级标题` `## 二级标题` 强调*斜体文本* **粗体文本** ~~在文字上添加删除线~~ 链接网站[链接名称](http://链接网址) &lt;http://链接网址&gt; [Google][1] [1]:http://www.google.com/ 插入代码块12var s = "JavaScript syntax highlighting";alert(s); 插入图片![图片名称](http://图片网址) 也可以使用 HTML 的图片语法来自定义图片的宽高大小 [站外图片上传中……(3)] 列表- 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对 引用&gt; 引用文本前使用 [大于号+空格] 换行如果另起一行，只需在当前行结尾加 2 个空格 如果是要起一个新段落，只需要空出一行即可。 分隔符 --- 高级语法使用HTML元素如图片居中：&lt;center&gt; &lt;/center&gt; 公式$$ x = {-b pm sqrt{b^2-4ac} over 2a} $$ 更详细说明Markdown 语法说明]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo美化]]></title>
    <url>%2F2017%2F12%2F25%2FHexo%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主题语言设置首先修改hexo根文件夹下的F:\hexo\_config.yml修改为language: zh-CN #网站使用的语言，然后修改主题文件的语言菜单项显示文本：设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项: menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设置favicon：favicon的全称Favorites Icon，即地址栏左侧的图标.有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件。打开主题配置文件_config.yml可以看到favicon的配置信息： # Put your favicon.ico into `hexo-site/source/` directory. favicon: /favicon.ico 添加标签与分类首先，主题配置文件中，在menu项下，要把tags页打开 menu: home: / categories: /categories #about: /about archives: /archives tags: /tags //确保标签页已打开 #schedule: /schedule #commonweal: /404.html 插入图片一种方法![图片名](链接) 另一种方法 主页配置文件_config.yml里post_asset_folder:这个选项设置为true 在hexo目录执行 npm install hexo-asset-image --save，下载安装一个可以上传本地图片的插件 之后运行hexo n &quot;xxxx&quot;生成md文章，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 检查，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt; 添加标签与分类hexo new page tags 确认站点配置文件里有tag_dir: tags确认主题配置文件里有tags: /tags编辑source/tags/index.md title: tags date: type: &quot;tags&quot; 添加多个标签tags: [标签1,标签2,标签3] 添加分类hexo new page categories 确认站点配置文件里category_dir: categories确认主题配置文件里有categories: /categories编辑站点的source/categories/index.md title: categories date: type: &quot;categories&quot; 文章自动添加categories在scaffold里有post.md，这是创建post的模板，添加相应的配置 菜单栏控制修改主题配置文件 # ------------------------------------------------------ # Menu Settings # ------------------------------------------------------ # When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives) menu: home: / #categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 侧栏设置在主题配置文件的sidebar字段，此处我直接设置为侧栏一直显示，而且显示在右边： sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. #display: post display: always #display: hide #display: remove 设置头像和作者名称在站点配置文件中，新加一个字段avatar，值就是头像的连接地址，将avatar.png放到本地目录hexo\source\images中；作者名称直接设置站点配置文件中author字段的值： # Site title: Linsh-何乐不为~ subtitle: description: author: Linshuhe avatar: /images/avatar.png language: zh-Hans timezone: 设置阅读全文在文章使用&lt;!--more--&gt;手动设置根据文章的内容，自己在合适的位置添加 &lt; !--more--&gt; 标签，使用灵活，也是Hexo推荐的方法。 在文章中的front-matter中添加description，并提供文章摘录这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。 自动形成摘要，在主题配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定 auto_excerpt: enable: true length: 150 参考来源 Hexo个人免费博客(三) next主题、评论、阅读量统计和站内搜索 Hexo-设置阅读全文 hexo生成博文插入图片]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
