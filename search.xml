<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法之快速排序及其改进]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[快速排序快速排序是一种经典的排序方式 代码实现12345678910111213141516171819public void quickSort(Comparable[] data, int left, int right) &#123; if (left &lt; right) &#123; int i = left, j = right; Comparable x = data[left]; while (i &lt; j) &#123; //i&lt;j 从右向左找到第一个小于x的数data[j] while (i &lt; j &amp;&amp; data[j].compareTo(x) &gt;= 0) j--; //i&lt;j 将找到的data[j]给 if (i &lt; j) data[i++] = data[j]; //从左向右找到第一个大于x得数，data[i] while (i &lt; j &amp;&amp; data[i].compareTo(x) &lt;= 0) i++; if (i &lt; j) data[j--] = data[i]; &#125; data[i] = x; //data[0...i-1] &lt; data[i] &lt; data[i+1...high] quickSort(data, left, i - 1); quickSort(data, i + 1, right); &#125;&#125; 改进 三向切分快速排序代码实现123456789101112131415161718192021222324//a[i] &lt; v，将 a[lt] 和 a[i]交换 lt 和 i 加一//a[i] &gt; v，将 a[gt] 和 a[i]交换 gt减一//a[i] = v，i++public void quickSort3way(T data[], int left, int right) &#123; if (left &lt; right)&#123; int lt = left, i = left + 1, gt = right; T x = data[left]; while (i &lt;= gt)&#123; int compar = data[i].compareTo(x); if (compar &lt; 0) swap(data, lt++, i++); else if (compar &gt; 0) swap(data, i, gt--); else i ++; &#125; //data[0...lt - 1] &lt; data[lt...gt] &lt; data[gt+1...right] quickSort3way(data, left, lt - 1); quickSort3way(data, gt + 1, right); &#125;&#125;private void swap(T a[], int i, int j)&#123; T temp = a[i]; a[i] = a[j]; a[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的递归与非递归遍历]]></title>
    <url>%2F2018%2F03%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树具有三种基本的遍历方式：前序遍历，中序遍历，后序遍历。 前序遍历：访问根结点-&gt;访问左子树-&gt;访问右子树中序遍历：访问左子树-&gt;访问根结点-&gt;访问右子树后序遍历：访问左子树-&gt;访问右子树-&gt;访问根节点 一般遍历采用递归方式，而递归又可以使用栈转化为非递归方式，栈的效率越高，非递归方式的效率越高。 递归方式1234567891011121314151617181920212223//前序遍历private void prePrint(Node&lt;T&gt; node)&#123; if (node == null) return; System.out.println(node.data); prePrint(node.left); prePrint(node.right);&#125;//中序遍历private void midPrint(Node&lt;T&gt; node) &#123; if (node == null) return; midPrint(node.left); System.out.println(node.data); midPrint(node.right);&#125;//后序遍历private void laPrint(Node&lt;T&gt; node)&#123; if (node == null) return; laPrint(node.left); laPrint(node.right); System.out.println(node.data);&#125; 非递归方式使用java.util.Stack实现栈 前序遍历使用非递归实现遍历二叉树，对任意节点node: 声明一个p节点指向node 访问节点p，将节点p入栈 判断栈或p节点有一方是否不为空，有一方不为空则进入下一判断，直至栈或p节点都为空 判断p节点是否空，p节点不为空，则输入p节点的数据，同时p节点入栈，p指向p的左节点，直至p节点为空（此时二叉树最左边的左孩子已经入栈） 判断栈是否为空，不为空取出栈顶节点并使p指向栈顶节点的右节点，直至栈为空 123456789101112131415161718192021/** * 非递归实现前序遍历 * @param node 访问节点 */private void preOrderStack(Node&lt;T&gt; node) &#123; if (node == null) return; Stack&lt;Node&lt;T&gt;&gt; st = new Stack&lt;&gt;(); Node&lt;T&gt; p = node; while (!st.isEmpty() || p!=null)&#123; while (p!=null)&#123; System.out.print(p.data + ", "); st.push(p); p = p.left; &#125; if (!st.isEmpty())&#123; p = st.pop(); //栈中保存节点信息，为下一步p=p.right做准备，不可忽略 p = p.right; &#125; &#125;&#125; 中序遍历和前序遍历类似，不同在于从栈取出节点后输出节点信息12345678910111213141516171819202122/** * 非递归实现中序遍历 * @param node 访问节点 */private void midOrderStack(Node node)&#123; if (node == null) return; Stack&lt;Node&lt;T&gt;&gt; st = new Stack&lt;&gt;(); Node&lt;T&gt; p = node; while (!st.isEmpty() || p!=null)&#123; while (p!=null)&#123; st.push(p); p = p.left; //一直遍历到左子树最左边，同时保存节点至栈 &#125; if (!st.empty())&#123; p = st.pop(); System.out.print(p.data + ", "); p = p.right; &#125; &#125;&#125; 后序遍历1234567891011121314151617181920212223242526272829303132/** * 非递归实现后序遍历（一） * @param node 节点 */private void postOrderStack1(Node&lt;T&gt; node) &#123; if (node == null) return; Stack&lt;Node&lt;T&gt;&gt; st = new Stack&lt;&gt;(); Node&lt;T&gt; curN = node;//当前访问节点 Node&lt;T&gt; lastN = null;//上次访问节点 while (curN != null)&#123; st.push(curN); curN = curN.left; //将curNode移到左子树最下边 &#125; while (!st.isEmpty())&#123; curN = st.pop(); if (curN.right == null || curN.right == lastN)&#123; //一个根节点被访问的条件是：无右子树或右子树已被访问过 System.out.print(curN.data + ", "); lastN = curN; //修改最近被访问的节点 &#125;else &#123; st.push(curN);//根节点再次入栈 curN = curN.right; while (curN != null)&#123; st.push(curN); curN = curN.left; &#125; &#125; &#125; System.out.println("\n");&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks介绍及搭建]]></title>
    <url>%2F2018%2F02%2F20%2FShadowsocks%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[我个人经常需要进行一些技术类问题的搜索学习，为了更好的使用Google进行学习，也为了接触学习一下Linux，自己就租一台vps。 Shadowsocks/R介绍很久以前的真正的互联网连接: 某一天，GFW出现了,每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是，某歌等就成了404。 聪明的人们想到了利用境外服务器代理的方法来绕过 GFW 的过滤，其中包含了各种HTTP代理服务、Socks服务、VPN服务… 其中以 ssh tunnel 的方法比较有代表性。1)首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户 由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题于是，shadowsocks出现了。 1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回 ShadowsocksR是在Shadowsocks的基础上开发的，相比原版支持更多的协议和混淆，更加密，因此我选择了SSR。 Shadowsocks/R服务端配置购买VPSVPS相当于你购买了一个 电脑，不过这个电脑是Linux系统（当然也有win系统的），需要远程链接。这里推荐一些便宜而又好用的vps厂商 搬瓦工搬瓦工对在国内用的人挺多的，有保障，支持更换ip，有个19美刀/年的套餐，个人使用完全足够，不过经常断货 vultr vultr是国际大牌厂商，也是国际三大vps供应商之一，产品有保障。 DigitalOcean 同样是国际大厂 以上三个都支持支付宝，而且购买套餐时建议选择KVM架构，它内置BBR优化，访问速度更快。更多vps推荐可以参考这里 VPS部署由于搬瓦工最便宜的套餐长期无货，我选择了vultr。注册账号后便可选择节点和套餐 最便宜的是2.5刀/月，不过我买的时候只有New York和Miami节点，这两个都在美国东海岸，连接速度和ping自然比不过其它节点，不过速度后面可以利用加速技术弥补。我选择了New York节点，CentOS 6，2.5刀/月套餐选好后，可以在这里开启IPv6 之后选择Deploy Now进行部署部署完成后可以查看你的vps信息。这时可以使用 Ping检测 检测你的ip在国内有没有被屏蔽，如果大部分国内节点显示连接超时，可以销毁这个服务器，重新部署一个。 Xshell连接VPS先在网上下载Xshell安装。安装完成后，打开Xshell，点击”文件-新建”，在”主机”一栏里填入你vps的IP Address，之后按照提示输入用户”root”和密码 连接成功后出现如图所示 部署SS/SSR我用的是ShadowsocksR一键部署管理脚本123yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/SSR.sh &amp;&amp; chmod +x SSR.sh &amp;&amp; bash SSR.sh 备用：123yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/SSR.sh &amp;&amp; chmod +x SSR.sh &amp;&amp; bash SSR.sh 复制代码粘贴到VPS服务器里，回车，脚本便自动安装。安装好后，启动命令为：bash ssr.sh 根据提示，依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为1-65535之间的数字)，回车键用于确认。建议端口设置为低位，最常用的是80和443。 设置加密方式，协议插件，混淆插件协议（Protocol）：origin，auth_sha1_v4，auth_aes128_md5，auth_aes128_sha1，auth_chain_a，auth_chain_b` 混淆（Obfs）：plain，http_simple，http_post，random_head，tls1.2_ticket_auth，tls1.2_ticket_fastauth(需06/04日以后的服务端版本) origin 和 plain 是原版，即ss可以用，加粗的是推荐使用的。 我用过的组合是chacha20+orgin+tls1.2_ticket_auth，兼容原版ss 部署好后出现下图信息 Shadowsocks/R本地配置下载Shadowsocks下载: 官网 Github 逗比云(Android) ShadowsocksR下载 逗比云(PC) 逗比云(Android) PC端配置 连接SSR之前最好关闭国产杀毒软件如360管家，腾讯电脑管家，百度卫士等。 最好不要使用国产浏览器如360急速浏览器，360安全浏览器，百度浏览器等。 北京大学校内VPN都禁止360这类软件。 如果不想自己的ip凉的太快，就尽量遵守以上规则，可以参考这里。 以SSR为例，下载完成后解压，双击运行ShadowsocksR-dotnet4.0.exe，之后复制服务端部署完成后的SSR连接，右键点击托盘的小飞机图标，选择”从剪切板导入” 点击确定 右键点击SSR，系统代理模式选择PAC或全局，代理规则选择“绕过局域网和大陆”或“全局”，之后可以打开ie或edge访问 谷歌 测试是否成功。如果不成功，可以尝试更改服务端的协议/混淆。 Android端配置 安装安卓版SSR 点这里 可以选择从剪切板导入还是二维码 导入成功之后，选择刚导入的节点 之后返回主界面，建议路由设置为“绕过局域网及中国大陆地址”，同时建议分应用代理，都是为了降低ip被屏蔽的概率 分应用代理，需要翻的应用开启 PC端高级使用技巧代理规则与PACSSR分两种规则方式：系统代理模式和代理规则。 PAC规则 是根据PAC文件中的黑白地址名单来判断那些网站走代理。也就是判断 流量是否进入客户端。 代理规则 是根据IP判断，按选择的规则来判断进入 客户端的流量是直连还是走代理。 例如，系统代理PAC，访问www.google.com，在PAC匹配到，于是走代理，SSR客户端受到访问谷歌数据，这时用代理规则判断。代理规则为绕过局域网，判断谷歌是不是局域网，是则直连，不是则走代理。其他绕过局域网和大陆等规则同理。 简单来说，系统代理模式判断是否让数据进入SSR客户端，代理规则判断进入SSR客户端的数据是走直连还是代理。 用户自定义规则代理规则中的 用户自定义，就是可以让你自定义什么域名或IP 走代理还是直连，比PAC更方便添加/编辑规则，以后完全可以抛弃 PAC，而改用 用户自定义 代理规则（系统代理模式选择全局，浏览器扩展也设置 127.0.0.1 1080(默认端口)）。 规则文件位置是在 ShadowsocksR.exe 客户端同目录下的 user.rule 文件。 提供一个github上规则 https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/gfwlist-user.rule 编辑规则可以自己编译user.rule来添加一些规则。 规则匹配结果类型有 四种：remoteproxy、localproxy、direct、reject。均可用于两类规则。 remoteproxy：经过SSR服务器连接（走代理） localproxy：经过本地代理连接，或没有配置本地代理时使用直连连接（本地代理指的是：选项设置 - 二级(前置)代理） direct：直连连接（直连，不走代理） reject：拒绝连接（可用于屏蔽广告，当然前提是用系统代理规则：全局模式，否则只有进入SSR客户端的广告才会被过滤） 123格式：hostname rule# 域名 规则 例如，Github在新疆被屏蔽，我可以编辑user-rule添加Github走代理：1.github.com remoteproxy 于是我再访问Github就会走代理。 Chrome配合SwitchyOmega使用SSR 首先下载 SwitchyOmega 这款插件 安装至Chrome后左键单击这个插件，选择”选项” 点击”新建情景模式”，填入名称如ShadowsocksR，选择”代理服务器”,之后创建。 在代理服务器填入如图，之后点击左侧“应用选项” 保存后切换至你刚新建的模式，就可以使用Chrome访问真正的互联网了。访问 谷歌 使用SwitchyOmega进行自动切换有时候我们同时访问国内网站和被屏蔽的网站，只想让被屏蔽的网站走代理。 使用SwitchyOmega新建情景模式，输入名称，选择“自动切换模式” “规则列表规则”选择刚刚创建的模式如我的“ShadowsocksR” 规则列表模式选择”AutoProxy”，规则列表网址填入https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，然后选择”立即更新情景模式”，更新成功后点击左侧”应用选项” 之后选择这个模式，对于屏蔽的网站会自动使用代理ShadowsocksR进行连接，没有被屏蔽的网站不会走代理。 优化ShadowsocksR简单介绍目前已知的优化速度方法有：KcpTun、TCP-BBR、锐速（Server Speeder）+LotServer、云语（Flash TCP）、服务器中继（国内中转）、高级算法hybla或者htcp。这里推荐TCP-BBR技术。BBR 是一个由谷歌社区开发的 TCP拥塞控制技术，目前处于开发初期，但是前景很棒，大家可以持续关注，同时BBR是集成与Linux最新版本的内核中的。而且谷歌自己的服务器都已经在使用这一技术。至于原理嘛，目前不懂，还是要多多学习。 BBR官方项目地址 https://github.com/google/bbr 部署如果你部署SSR是使用的上面的一键部署管理脚本，这个脚本自带一键部署BBR。 连接你的VPS使用bash ssr.sh启动你的SSR，选择”14 其他功能”，之后选择”1 配置BBR”等待一会BBR就会配置好。 之后提示重启VPS， 等待十几秒，使用Xshell重新连接VPS，输入命令查看BBR是否开启bash bbr.sh status，结果出现BBR就说明成功 虽然节点选择了New York，但是经过一番优化后速度已经达标，白天油管4k无压力。 最后”墙“越来越高，且翻且珍惜。 参考： 自己搭建ss/SSR服务器教程（适合初学者，最低2.5美元/月） Shadowsocks指导篇（总结归类）——从无到有，境无止尽！ ShadowsocksR PC客户端中的 [代理规则 – 用户自定义] 功能使用教程]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>ShadowsocksR</tag>
        <tag>VPS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之排序（一）]]></title>
    <url>%2F2018%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序尽管实际中我们可以使用标准库中的函数完成排序而不需要自己实现，学习排序仍有很强的实际意义。 插入排序插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 时间复杂度 最好情况：数组有序，每插入一个元素，只需要比较前一个元素，时间复杂度为O(N) 最坏情况：插入第N个元素，要考虑前N - 1个元素，比较次数为1+2+3+..+n-1，即N^2/2，时间复杂度O(N^2) 代码实现1234567891011121314151617public void sort(Comparable[] data) &#123; sort(data, data.length); &#125;private void sort(Comparable[] data, int len) &#123; int i, j; Comparable key; for (i = 1; i &lt; len; i++) &#123; key = data[i]; for (j = i - 1; j &gt;= 0; j--) &#123; int cmp = data[j].compareTo(key); if (cmp &gt; 0) data[j + 1] = data[j]; else break; &#125; data[j + 1] = key; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之树（二）]]></title>
    <url>%2F2018%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平衡二叉树平衡二叉树（AVL）是一种改进后的二叉树，它每个结点的左子树和右子树的高度最多相差1。它的关键之处在于，插入和删除节点时通过旋转保持平衡。 时间复杂度插入操作时间复杂度为O(logn)，不会出现二叉查找树的最坏情况。 推导过程N(h) = N(h-1) + N(h-2) + 1 N(h) = N(h-1) + N(h-1) + 1 = 2N(h-1) + 1 N(h)=O(2h)=&gt;h=logn≈O(logn) N(h-1) 代表高度为h-1的左子树的最小结点数 N(h-2) 代表高度为h-2的右子树的最小结点数 1 代表当前结点(根)。 AVL树的旋转左左单旋转（LL）型在平衡二叉树的左子树的左子树插入一个节点，导致平衡二叉树失衡，这就是LL情形此时需要进行右旋，使其恢复平衡。 代码实现123456789101112131415/*** LL型 进行右旋操作** @param node 失衡的节点* @return 新的根节点*/private Node&lt;T&gt; leftLeftRotate(Node&lt;T&gt; node) &#123; //声明一个newnode指向失衡节点的左节点 Node&lt;T&gt; newNode = node.left; //newnode的右节点变为失衡节点的左节点 node.left = newNode.right; //失衡节点成为新节点的右节点 newNode.right = node; return newNode;&#125; 右右单旋转（RR）型同LL型相反，在平衡二叉树的右子树的右子树插入节点，失衡，此时进行左旋操作使其恢复平衡。 代码实现123456789101112/*** RR型 进行左旋操作** @param node 失衡节点* @return 新的根节点*/private Node&lt;T&gt; rightRightRotate(Node&lt;T&gt; node) &#123; Node&lt;T&gt; newNode = node.right; node.right = newNode.left; newNode.left = node; return newNode;&#125; 左右双选转型（LR）这种情况是在左子树的右子树插入节点造成失衡，这是需要先进行一次左旋转，再进行一次右旋转使其恢复平衡。 实现代码12345678910/*** LR型 失衡点的左子树进行左旋， 新的根节点再进行右旋** @param node 根节点* @return 新的根节点*/private Node&lt;T&gt; leftRightRotate(Node&lt;T&gt; node) &#123; node.left = rightRightRotate(node.left); return leftLeftRotate(node);&#125; 右左双旋转型（RL）理解了左右双旋，这里的实现也是同样的道理12345678910/*** RL型 失衡节点的右子树先进行右旋 新根节点左旋** @param node 根节点* @return 新的根节点*/private Node&lt;T&gt; rightLeftRotate(Node&lt;T&gt; node) &#123; node.right = leftLeftRotate(node.right); return rightRightRotate(node);&#125; AVL树的插入首先要判断插入节点是否平衡，需要计算节点的高度 123456789101112131415/*** 以node为根节点的树的高度** @param node 根节点* @return node的高度*/private int deep(Node&lt;T&gt; node) &#123; int h1, h2; if (node == null) return 0; else &#123; h1 = deep(node.left); h2 = deep(node.right); &#125; return (h1 &gt; h2 ? h1 : h2) + 1;&#125; 插入12345678910111213141516171819202122232425262728/*** 插入数据** @param data*/public void insert(T data) &#123; root = insert(data, root);&#125;private Node&lt;T&gt; insert(T data, Node&lt;T&gt; node) &#123; if (node == null) node = new Node&lt;&gt;(data); else if (data.compareTo(node.data) &lt; 0) &#123; node.left = insert(data, node.left); if (deep(node.left) - deep(node.right) == 2) &#123; if (data.compareTo(node.left.data) &lt; 0)//左子树的左节点，进行右旋操作 node = leftLeftRotate(node); else node = leftRightRotate(node);//左子树的右节点 进行左旋 &#125; &#125; else &#123; node.right = insert(data, node.right); if (deep(node.right) - deep(node.left) == 2) &#123; if (data.compareTo(node.right.data) &lt; 0)//右子树的左节点 先右旋后左旋 node = rightLeftRotate(node); else node = rightRightRotate(node); &#125; &#125; return node;&#125; 判断AVL树是否平衡123456789101112131415161718private boolean isBalanced = true;public boolean IsBalanced() &#123; getDepth(root); return isBalanced;&#125;private int getDepth(Node&lt;T&gt; root) &#123; if (root == null) return 0; int left = getDepth(root.left); int right = getDepth(root.right); if (Math.abs(left - right) &gt; 1) &#123; isBalanced = false; &#125; return right &gt; left ? right + 1 : left + 1;&#125; 参考 java数据结构与算法之平衡二叉树(AVL树)的设计与实现 《算法（第四版）》]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之树（一）]]></title>
    <url>%2F2018%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉树定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。 二叉树的性质 深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点 具有n个结点的完全二叉树的深度为log2(n+1) 给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1) 完全二叉树和满二叉树完全二叉树：完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。 二叉查找树又称为是二叉排序树（Binary Sort Tree）或二叉搜索树性质：对二叉查找树进行中序遍历，即可得到有序的数列 时间复杂度同二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。 二叉查找树的创建与插入插入（递归实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class BST&lt;T extends Comparable&lt;T&gt;&gt; &#123; class Node&lt;T&gt; &#123; private T data;//节点数据 private Node&lt;T&gt; left;//左子节点 private Node&lt;T&gt; right;//右子节点 public Node(T data) &#123; this.data = data; &#125; private Node(T data, Node&lt;T&gt; left, Node&lt;T&gt; right) &#123; this.data = data; this.left = left; this.right = right; &#125; &#125; private Node&lt;T&gt; root;//根节点 public void insert(T data) &#123; root = insert(data, root); &#125; private Node&lt;T&gt; insert(T data, Node&lt;T&gt; node) &#123; if (node == null) return new Node&lt;&gt;(data); int com = data.compareTo(node.data); //插入数据小于当前节点数据，数据存放到到当前节点的左节点，否则存放到右节点 if (com &lt; 0) node.left = insert(data, node.left); else if (com &gt; 0) node.right = insert(data, node.right); else node.data = data; return node; &#125; public void print() &#123; midPrint(root); &#125; //中序遍历输出 private void midPrint(Node&lt;T&gt; node) &#123; if (node == null) return; midPrint(node.left); System.out.println(node.data); midPrint(node.right); &#125;&#125; 二叉查找树的遍历二叉查找树同其他二叉树一样，具有三种基本的遍历方式：前序遍历，中序遍历，后序遍历。 前序遍历：访问根结点-&gt;访问左子树-&gt;访问右子树中序遍历：访问左子树-&gt;访问根结点-&gt;访问右子树后序遍历：访问左子树-&gt;访问右子树-&gt;访问根节点 使用递归实现三种遍历1234567891011121314151617181920212223//前序遍历private void prePrint(Node&lt;T&gt; node)&#123; if (node == null) return; System.out.println(node.data); prePrint(node.left); prePrint(node.right);&#125;//中序遍历private void midPrint(Node&lt;T&gt; node) &#123; if (node == null) return; midPrint(node.left); System.out.println(node.data); midPrint(node.right);&#125;//后序遍历private void laPrint(Node&lt;T&gt; node)&#123; if (node == null) return; laPrint(node.left); laPrint(node.right); System.out.println(node.data);&#125; 返回树的深度123456789private int deepTree(Node&lt;T&gt; node) &#123; int leftd, rightd; if (node == null) return 0; else &#123; leftd = deepTree(node.left); rightd = deepTree(node.right); &#125; return (leftd &gt; rightd ? leftd : rightd) + 1;&#125; 删除操作删除节点分为三种情况： 删除叶子节点 删除有一个孩子的节点 删除有两个孩子的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean delete(T data) &#123; if (root == null) return false; //st 树的根节点，pt st的双亲 Node&lt;T&gt; st = root, pt = null; //首先查找到要删除的节点 while (st != null) &#123; int temp = data.compareTo(st.data); //小于节点数据，向左查找 //否则向右查找，找到退出循环 if (temp &lt; 0) &#123; pt = st; st = st.left; &#125; else if (temp &gt; 0) &#123; pt = st; st = st.right; &#125; else break; &#125; //没有找到删除节点 if (st == null) return false; if (st.left == null &amp;&amp; st.right == null) &#123; //删除的节点为叶子节点 if (st == root) root = null; else if (pt.left == st) pt.left = null; else pt.right = null; &#125; else if (st.left == null || st.right == null) &#123; //单叶节点 if (st == root) &#123; if (st.left == null) root = st.right; else root = st.left; &#125; else if (pt.left == st) &#123; if (st.left == null) pt.left = st.right; else pt.left = st.left; &#125; else if (pt.right == st) &#123; if (st.left == null) pt.right = st.right; else pt.right = st.left; &#125; &#125; else &#123; //双叶节点 Node&lt;T&gt; s1 = st, s2 = st.left; while (s2.right != null) &#123; s1 = s2; s2 = s2.right; &#125; st.data = s2.data; if (s1 == st) st.left = s2.left; else s1.right = s2.left; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据结构与算法之栈与队列]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈栈的定义栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 栈的特点 后进先出（rear In front Out），简称为LIFO 限定只能在栈顶进行插入和删除操作。 n个数依次入栈，则出栈方式共有C（2n,n）/(n+1)种 栈的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** 基于链表的栈的实现*/public class Stack&lt;T&gt; &#123; class Node&lt;T&gt; &#123; //使用内部类创建节点 private T data; private Node&lt;T&gt; next; private Node(T data) &#123; this.data = data; &#125; private Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; private T getData() &#123; return data; &#125; &#125; Node&lt;T&gt; root;//栈顶指针 int top = 0;//栈容量 public void push(T data) &#123; //入栈 //另一种描述 Node&lt;T&gt; oldRoot = root; root = new Node&lt;T&gt;(data); root.next = oldRoot; top++; &#125; /*public void push(T data)&#123; root = new Node&lt;T&gt;(data, root); top ++; &#125;*/ public T pop() &#123; //出栈 if (top &lt;= 0) return null; T getData = root.getData(); root = root.next; top--; return getData; &#125; public T peek() &#123; //返回栈顶元素 return root.getData(); &#125; public boolean isEmpty() &#123; //判断是否为空栈 return top == 0; &#125; public void clear()&#123; //清空栈 root = null; top = 0; &#125;&#125; 栈的应用 数值转换 表达式求值 浏览器历史纪录 解析xml/json等 使用栈进行十进制转任意进制1234567891011121314151617181920212223/** * 十进制转任意进制（最高16） * * @param dec * @param hex * @return 字符串形式的转换结果 */public String hex(int dec, int hex) &#123; Stack&lt;Integer&gt; stackHex = new Stack&lt;&gt;(); StringBuilder strHex = new StringBuilder(); String str = "0123456789ABCDE"; int rem = 0; while (dec &gt; 0) &#123; rem = dec % hex; dec /= hex; stackHex.push(rem); &#125; while (!stackHex.isEmpty()) strHex.append(str.charAt(stackHex.pop())); return strHex.toString();&#125; 队列队列是一种特殊的线性表，只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。 队列的特点 先进先出（First In First Out），FIFO 队列的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 利用链表实现队列*/public class Queue&lt;T&gt; &#123; class Node&lt;T&gt; &#123; //队列节点 private T data; private Node&lt;T&gt; next; private Node(T data) &#123; this.data = data; &#125; &#125; private Node&lt;T&gt; front; //队首指针 private Node&lt;T&gt; rear; //队尾指针 private int n; //队列容量 public void Enqueue(T data) &#123; //入队 Node&lt;T&gt; oldrear = rear; rear = new Node&lt;&gt;(data); rear.next = null; if (isEmpty()) front = rear; else oldrear.next = rear; n++; &#125; public T Dequeue() &#123; //出队 if (isEmpty()) return null; T data = front.data; front = front.next; n--; if (isEmpty()) rear = null; return data; &#125; public T peek() &#123; //查看队首元素 if (isEmpty()) return null; return front.data; &#125; public boolean isEmpty() &#123; //判断队列是否为空 return front == null; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年度小结]]></title>
    <url>%2F2017%2F12%2F31%2F2017%E5%B9%B4%E5%BA%A6%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2017年算是颇有收获的一年。&emsp;&emsp;确定了自己毕业后要从事的方向，跟自己的专业没有太大关系，所以基本要靠自学了。想想或许这也不是什么坏事，可以按照自己喜欢的方式学习，还能锻炼学习能力。 关于学习&emsp;&emsp;这一年里，基于兴趣学习了几门流行的编程语言，学习了前端的一些基本知识。上半年开始了自己的自学之路，由于之前没有任何编程基础，同时本专业还有一些任务，靠挤时间花了大半个学期算是学完了Java的基础部分。下半年已经确定进入互联网搬砖，开始有计划的学习。虽然学习完了数据结构，但是自己的计划没有完全完成。总结起来，一是前期的学习比较杂乱，几乎是在同时学习前端+python+javaweb+其他，之后发现这样的学习效率并不高，于是将主要精力集中在数据结构，才能基本完成计划。二是还在兼顾专业课，现在觉得不应该在专业课下太多的功夫，说到底还是自己缺乏背水一战的决心。 个人博客&emsp;&emsp;不久前接触到了几个不错的个人博客，后来偶然了解到可以用Hexo+github搭建个人博客，出于折腾心理自己也搭建了一个。看过很多大神分享的面经，他们都有一个共同的习惯：总结。这也是我搭建博客的一个原因，静下心来写写总结，记录下自己的学习，生活，沉淀自己。 关于生活电影&emsp;&emsp;不知什么时候开始喜欢上看电影。作为第八艺术，一部优秀的电影足以带给你很多启示。高考后看完了很多经典电影。像《肖申克的救赎》，《霸王别姬》，《蝙蝠侠：黑暗骑士》。。。慢慢的意识到，虽然自己没有写影评的文笔，但应该记录下看过的电影。于是从下半年开始记录自己看过的电影。 游戏&emsp;&emsp;不久前入正了《巫师3：狂猎》，这是我第一款入正的游戏，也是我游戏时间最长的一款游戏，2017年的娱乐时间基本给了它。盗版已经快要玩通了，现在入正来表示对CD Projekt RED的支持，毕竟以后难得再遇到这样优秀的游戏。 关于感情不存在的]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>年度小结</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Ubuntu 16.04双系统]]></title>
    <url>%2F2017%2F12%2F29%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu-16-04%E5%8F%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[准备体验一下Linux，就在原有的Windows10系统下，安装Ubuntu官方会长期提供支持的最新的Ubuntu 16.04。记录一下自己的安装过程。 准备过程 准备工具U盘，Ubuntu 16.04 LTS镜像，启动U盘制作软件 分区分区我用的是DiskGenius这款软件，将自己的一个盘分出了50G的空白空间。之后点击这空白空间，新建分区。 制作U盘启动盘运行下载好的 rufus 这个软件，载入下载的Ubuntu镜像，之后点击开始，一路点击确定，等待一会，写入成功。 成功后如下图 安装 从U盘启动U盘插在电脑上，选择启动方式为U盘启动，（设置U盘启动可以进入BIOS） 安装Ubuntu选择了U盘启动后，会出现如下“欢迎”界面，选择中文后，点击“安装Ubuntu”; 选择安装类型最好选择“其他选项” 安装位置和磁盘分区这是很关键的一步。双击前面分好的空白分区，分配分区网上的建议分区大小 /boot - 200 MB ； 实际需求大约 100 ~ 200MB，建议分配 200 或者 300 MB。 / - 15-20 GB ； 15-20 GB 对于大多数用户来说是一个比较合适的取值。 /home - [不定] ； 通常用于存放用户数据，下载的文件和媒体文件。在桌面系统中，/home 通常是最大的文件系统。(个人建议: 多多益善) swap - [不定] ；内存（大于 1024 MB），可以分配较少的空间甚至不需要swap 分区。 装双系统，/boot 选择”逻辑分区”就行了 “/boot” 分区: “逻辑分区”、”空间起始位置”、”Ext4日志文件系统”、挂载点”/boot” ”/“分区： ”逻辑分区“、”空间起始位置“、”Ext4日志文件系统“、挂载点”/“ ”/home“分区：”逻辑分区“、”空间起始位置“、”Ext2文件系统“、挂载点”/home“ ”交换空间“：”逻辑分区“、”空间起始位置“、”交换空间“ “安装启动引导器的设备”选择/boot对应的分区 检查无误之后，点击“现在安装” 检查分区 选择区域，键盘 设置用户名及密码 安装，重启 安装成功后我的机子算是三系统共存，Windows10 + Ubuntu + Phoenix OS，选择不同的系统方法也很简单，开机之后屏幕左下提示选择启动方式，这时按下“Esc”按钮，就会进入启动管理，之后选择要启动的系统，进入即可。 参考来源Windows下安装Ubuntu 16.04双系统]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2017%2F12%2F28%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法基本语法标题`# 一级标题` `## 二级标题` 强调*斜体文本* **粗体文本** ~~在文字上添加删除线~~ 链接网站[链接名称](http://链接网址) &lt;http://链接网址&gt; [Google][1] [1]:http://www.google.com/ 插入代码块12var s = "JavaScript syntax highlighting";alert(s); 插入图片![图片名称](http://图片网址) 也可以使用 HTML 的图片语法来自定义图片的宽高大小 [站外图片上传中……(3)] 列表- 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对 引用&gt; 引用文本前使用 [大于号+空格] 换行如果另起一行，只需在当前行结尾加 2 个空格 如果是要起一个新段落，只需要空出一行即可。 分隔符 --- 高级语法使用HTML元素如图片居中：&lt;center&gt; &lt;/center&gt; 公式$$ x = {-b pm sqrt{b^2-4ac} over 2a} $$ 更详细说明Markdown 语法说明]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo美化]]></title>
    <url>%2F2017%2F12%2F25%2FHexo%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主题语言设置首先修改hexo根文件夹下的F:\hexo\_config.yml修改为language: zh-CN #网站使用的语言，然后修改主题文件的语言菜单项显示文本：设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项: menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设置favicon：favicon的全称Favorites Icon，即地址栏左侧的图标.有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件。打开主题配置文件_config.yml可以看到favicon的配置信息： # Put your favicon.ico into `hexo-site/source/` directory. favicon: /favicon.ico 添加标签与分类首先，主题配置文件中，在menu项下，要把tags页打开 menu: home: / categories: /categories #about: /about archives: /archives tags: /tags //确保标签页已打开 #schedule: /schedule #commonweal: /404.html 插入图片一种方法![图片名](链接) 另一种方法 主页配置文件_config.yml里post_asset_folder:这个选项设置为true 在hexo目录执行 npm install hexo-asset-image --save，下载安装一个可以上传本地图片的插件 之后运行hexo n &quot;xxxx&quot;生成md文章，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 检查，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt; 添加标签与分类hexo new page tags 确认站点配置文件里有tag_dir: tags确认主题配置文件里有tags: /tags编辑source/tags/index.md title: tags date: type: &quot;tags&quot; 添加多个标签tags: [标签1,标签2,标签3] 添加分类hexo new page categories 确认站点配置文件里category_dir: categories确认主题配置文件里有categories: /categories编辑站点的source/categories/index.md title: categories date: type: &quot;categories&quot; 文章自动添加categories在scaffold里有post.md，这是创建post的模板，添加相应的配置 菜单栏控制修改主题配置文件 # ------------------------------------------------------ # Menu Settings # ------------------------------------------------------ # When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives) menu: home: / #categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 侧栏设置在主题配置文件的sidebar字段，此处我直接设置为侧栏一直显示，而且显示在右边： sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. #display: post display: always #display: hide #display: remove 设置头像和作者名称在站点配置文件中，新加一个字段avatar，值就是头像的连接地址，将avatar.png放到本地目录hexo\source\images中；作者名称直接设置站点配置文件中author字段的值： # Site title: Linsh-何乐不为~ subtitle: description: author: Linshuhe avatar: /images/avatar.png language: zh-Hans timezone: 设置阅读全文在文章使用&lt;!--more--&gt;手动设置根据文章的内容，自己在合适的位置添加 &lt; !--more--&gt; 标签，使用灵活，也是Hexo推荐的方法。 在文章中的front-matter中添加description，并提供文章摘录这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。 自动形成摘要，在主题配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定 auto_excerpt: enable: true length: 150 参考来源 Hexo个人免费博客(三) next主题、评论、阅读量统计和站内搜索 Hexo-设置阅读全文 hexo生成博文插入图片]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
