<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[设计模式-单例模式]]></title>
      <url>/2019/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>保证一个类只有一个实例，提供一个访问他的全局访问点</p>
<a id="more"></a>    
<h2 id="多种实现"><a href="#多种实现" class="headerlink" title="多种实现"></a>多种实现</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。一般情况下使用。</p>
<h3 id="2-懒汉模式-线程不安全"><a href="#2-懒汉模式-线程不安全" class="headerlink" title="2. 懒汉模式(线程不安全)"></a>2. 懒汉模式(线程不安全)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例</p>
<h3 id="3-懒汉模式-（线程安全）"><a href="#3-懒汉模式-（线程安全）" class="headerlink" title="3. 懒汉模式 （线程安全）"></a>3. 懒汉模式 （线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>synchronized</code>,每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，</p>
<h3 id="4-双重检查模式（DCL）"><a href="#4-双重检查模式（DCL）" class="headerlink" title="4. 双重检查模式（DCL）"></a>4. 双重检查模式（DCL）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检验锁模式（double checked locking pattern）</p>
<h3 id="5-静态内部类单例模式（推荐）"><a href="#5-静态内部类单例模式（推荐）" class="headerlink" title="5. 静态内部类单例模式（推荐）"></a>5. 静态内部类单例模式（推荐）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCEE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCEE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h3 id="6-枚举类（最佳）"><a href="#6-枚举类（最佳）" class="headerlink" title="6. 枚举类（最佳）"></a>6. 枚举类（最佳）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下使用第一种 <strong>饿汉模式</strong>，明确要求要懒加载（lazy initialization），使用第五种静态内部类。涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">设计模式（二）单例模式的七种写法</a></li>
<li><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">菜鸟教程-单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用docker-compose构建Redis]]></title>
      <url>/2019/03/23/%E4%BD%BF%E7%94%A8docker-compose%E6%9E%84%E5%BB%BARedis/</url>
      <content type="html"><![CDATA[<p>介绍使用docker-compose安装Redis</p>
<a id="more"></a>
<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/conf/redis/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/conf/redis/data:/data</span>  </span><br><span class="line"><span class="attr">    restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker-compose </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java虚拟机-笔记]]></title>
      <url>/2019/03/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>《深入理解Java虚拟机》读书笔记</p>
<a id="more"></a>    
<h2 id="Java运行时数据区"><a href="#Java运行时数据区" class="headerlink" title="Java运行时数据区"></a>Java运行时数据区</h2><p>分为：程序计数器，Java虚拟机栈，本地方法区，Java堆，方法区</p>
<p>程序计数器，Java虚拟机，本地方法区是线程私有，随线程而生，随线程而灭。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空），分支，跳转，异常处理都需要计数器完成。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等信息。每一个方法从调用到执行完成的过程，对应一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>为虚拟机使用到的Native方法服务。</p>
<p>异常：</p>
<ul>
<li>StackOverError，</li>
<li>OutOfMemoryError</li>
</ul>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>被所有线程共享。存放对象实例，是垃圾收集器管理的主要区域，“GC堆”。</p>
<p>异常：</p>
<ul>
<li>OutOfMemoryError</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享。存放被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。<br>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。具备动态性。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>主要针对堆和方法区。</p>
<h3 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>目前主流Java虚拟机没有使用这种方法。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>虚拟机栈引用的对象</li>
<li>方法区静态属性引用对象</li>
<li>常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>强引用</li>
</ul>
<p>强引用的对象不会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<ul>
<li>软引用</li>
</ul>
<p>有用但非必须的对象。在内存不够的情况下被回收。</p>
<ul>
<li>弱引用</li>
</ul>
<p>一定会被回收。</p>
<ul>
<li>虚引用</li>
</ul>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<h4 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h4><p>一个对象死亡经历两次标记过程。第一次，使用可达性分析算法标记，判断对象是否需要执行<code>finalize()</code>方法，如果有必要执行，被一个低优先级的Finalizer线程执行。<code>finalize()</code>方法是对象逃脱死亡的最后一次机会。如果对象在<code>finalize()</code>中没有重新与引用链上任何一个对象建立关联，则会被回收。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>方法区主要存放永久代对象。主要是对常量池的回收和对类的卸载。</p>
<p>类卸载条件：</p>
<ul>
<li>该类所有的实例已经被回收，Java堆中不存在该类的任何实例</li>
<li>加载该类的CladdLoader被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>两个阶段：标记，清除。首先标记所有需要回收的对象，标记完成统一回收。</p>
<p>不足：</p>
<ul>
<li>标记和清除效率都不高</li>
<li>标记清除后会产生大量不连续的内存碎片</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>不足为只用内存的一半</p>
<p>使用该算法收集新生代</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>将Java堆分为新生代和老年代。新生代选用复制算法，老年代使用：标记-清除或者标记-整理算法。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2019/03/22/深入理解Java虚拟机-笔记/F:/Hexo\source\_posts\assets\garbaecollection.jpg" alt=""></p>
<h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p><strong>单线程收集器</strong>，进行垃圾收集时，必须暂停其他所有线程。</p>
<p>优点：简单高效，单个CPU环境，单线程收集效率高。</p>
<p>是Client模式下默认的新生代收集器。</p>
<h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p>Serial收集器的<strong>多线程</strong>版。</p>
<p>Server模式下虚拟机的默认新生代收集器。</p>
<h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>使用<strong>复制算法</strong>，多线程。</p>
<p>其他收集器关注点是尽量缩短垃圾收集时用户线程的停顿时间，它的目的是达到一个可控的<strong>吞吐量</strong>。</p>
<h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p>Serial收集器的老年代版本，<strong>单线程</strong>，使用 <strong>标记-整理算法</strong></p>
<p>Srver场景：</p>
<ul>
<li>作为CMS收集器的后备</li>
<li>JDK1.5 前与 Parallel Scavenge收集器搭配</li>
</ul>
<h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p>Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h4><p>基于 <strong>标记-清除算法</strong></p>
<p>流程：</p>
<ul>
<li>初始标记：标记GC Roots能直接关联到的对象，速度快。需要<strong>Stop The World</strong></li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要<strong>Stop The World</strong></li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>优点：并发收集，低停顿</p>
<p>缺点：</p>
<ul>
<li>对CPU资源敏感，因此吞吐量低</li>
<li>无法处理浮动垃圾，</li>
<li>标记 - 清除算法导致的空间碎片</li>
</ul>
<h4 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>特点：</p>
<ul>
<li>并行与并发：使用多个CPU缩短 STW的时间</li>
<li>分代收集：</li>
<li>空间整合：整体使用 <strong>标记-整理 算法</strong>，局部使用<strong>复制算法</strong></li>
<li>可预测的停顿</li>
</ul>
<p>收集范围是整个Java堆，把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 </p>
<p>步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>Minor GC：发生在新生代的垃圾收集，频繁，回收速度快</li>
<li>Full GC：发生在老年代的垃圾收集。伴随着至少一次的Minor GC，速度慢。</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h4><p>大多数情况下，对象优先在新生代Eden分配。当Eden空间不够时，发起Minor GC。</p>
<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>最典型的大对象是那种很长的字符串以及数组。</p>
<h4 id="3-长期存活对象直接进入老年代"><a href="#3-长期存活对象直接进入老年代" class="headerlink" title="3. 长期存活对象直接进入老年代"></a>3. 长期存活对象直接进入老年代</h4><p>对象在Eden出生并经历第一次Minor GC后任然存活，并能被Survivor接受，将被移动到Survivor空间，对象年龄为1,。对象在Survivor区每熬过一次，Minor GC，年龄增加一岁，增加到（默认15岁）被晋升到老年代中。</p>
<p>年龄阈值通过<code>-XX:PretenureSizeThreshold</code>设定</p>
<h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年两大于等于改年龄的对象直接进入老年代。</p>
<h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，Survivor空间无法容纳的对象直接进入老年代。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>比较两个类是否相等，只有在两个类有同一个类加载器加载的前提下才有意义，否则，即使这两个类来自于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，这连个类必定不相等。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/2019/03/22/深入理解Java虚拟机-笔记/F:/Hexo\source\_posts\assets\双亲委派模型.png" alt=""></p>
<p>双亲委派模型要求，除了顶层的启动类加载器，其他加载器都应该有自己的父类加载器。类加载器以组合的关系复用父加载器。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>如果一个类加载器收到了类加载请求，它首先不会加载这个类，而是把这个请求委派给父类加载器完成，每一层次都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求，子加载器才会尝试自己加载。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>Java类随着他的加载器有了带有优先级的层次关系。例如 <code>java.lang.Object</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2017.</li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">CS-Notes-Java 虚拟机</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[西南交大教务模拟登陆]]></title>
      <url>/2019/01/29/%E8%A5%BF%E5%8D%97%E4%BA%A4%E5%A4%A7%E6%95%99%E5%8A%A1%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</url>
      <content type="html"><![CDATA[<p>最近由于需要做一个获取学生课表的项目，就去研究了下如何模拟登录，并用Python成功模拟登录。在此记录一下自己的分析过程。</p>
<a id="more"></a>    
<h2 id="登录分析"><a href="#登录分析" class="headerlink" title="登录分析"></a>登录分析</h2><p>使用Chrome登录<a href="http://dean.vatuu.com/service/login.html" target="_blank" rel="noopener">教务网</a>，打开调试模式，使用NetWork记录点击“登录按钮”后发生的过程</p>
<ul>
<li>点击登录后浏览器请求的地址为<code>http://dean.vatuu.com/vatuu/UserLoginAction</code>，这就是我们需要记录的一个url，模拟登录时就向改网址发送请求；</li>
<li>我们需要重点分析Header和cookie。查看<code>Response Header</code>，该网址返回的Header信息有个<code>Set-Cookie</code>字段；在<code>Request-Headers</code>中，有一个<code>JSESSIONID</code></li>
<li><code>UserLoadingAction</code>是登录成功后跳转的一个页面。查看<code>Request Header</code>中的<code>Cookie</code>为学号+JSESSIONID，因此明白JSESSIONID以及如何获取它至关重要。</li>
<li>另一个问题就是验证码，我采用人工输入的方式。审查元素，查看验证码的接口，得到其地址。</li>
<li>复制这个地址，粘贴到地址栏，得到验证码。</li>
<li>我猜想验证码和<code>JSESSIONID</code>有很大关系。退出教务登录，打开调试工具的“Application-Cookies”可以看到保存的Cookie，清除</li>
<li>刷新验证码地址，可以看到会再次出现<code>JSESSIONID</code></li>
<li>因此可以假设通过验证码获取<code>JSESSIONDI</code></li>
</ul>
<h2 id="使用Python尝试登录"><a href="#使用Python尝试登录" class="headerlink" title="使用Python尝试登录"></a>使用Python尝试登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jsessionid</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    访问登录界面，通过Response Header用于获取set-cookie</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = requests.Session()</span><br><span class="line">    r = s.get(get_photo_url)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./static/ranstring.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(r.content)</span><br><span class="line">    get_head = r.headers</span><br><span class="line">    set_cookie = str(get_head[<span class="string">'Set-Cookie'</span>])</span><br><span class="line">    jessid = set_cookie.split(<span class="string">';'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> jessid</span><br></pre></td></tr></table></figure>
<p>运行后，可以看到获取到了<code>JSESSIONID</code>。</p>
<p>之后模拟登录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jsessionid = get_jsessionid()</span><br><span class="line">full_cookie = <span class="string">'username='</span>+str(data[<span class="string">'username'</span>])+<span class="string">'; '</span> + str(jsessionid)</span><br><span class="line">log_msg = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    登录</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 登录需要的cookie只有jsessionid</span></span><br><span class="line">    headers[<span class="string">'cookie'</span>] = jsessionid</span><br><span class="line">    data[<span class="string">'ranstring'</span>] = input(<span class="string">"验证码："</span>)</span><br><span class="line">    <span class="comment"># UserLoginAction</span></span><br><span class="line">    res = requests.post(</span><br><span class="line">        user_log_url, data, headers=headers, allow_redirects=<span class="keyword">True</span>)</span><br><span class="line">    log_msg = res.text</span><br><span class="line">    log_msg = json.loads(log_msg)</span><br><span class="line">    print(log_msg[<span class="string">'loginMsg'</span>])</span><br></pre></td></tr></table></figure>
<p>看到出现教务返回的登录成功等字样就表示登录成功。</p>
<p>尝试获取课表时，却提示未登录。我认为<code>UserLoadingAction</code>这一步也是必须的。</p>
<h2 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h2><ul>
<li>查看<code>UserLoadingAction</code>，发现向它传送的数据中有一个“loginMsg”字段，这正是点击‘’登录系统“成功后返回的字段的一部分</li>
<li>在登录时访问<code>UserLoadingAction</code>查看是否生效</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    登录</span></span><br><span class="line"><span class="string">    两步：UserLoginAction + UserLoadingAction</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    headers[<span class="string">'cookie'</span>] = jsessionid</span><br><span class="line">    data[<span class="string">'ranstring'</span>] = input(<span class="string">"验证码："</span>)</span><br><span class="line">    <span class="comment"># UserLoginAction</span></span><br><span class="line">    res = requests.post(</span><br><span class="line">        user_log_url, data, headers=headers, allow_redirects=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># with open('./response.html') as file:</span></span><br><span class="line">    <span class="comment"># file.writer(response.text)</span></span><br><span class="line">    log_msg = res.text</span><br><span class="line">    log_msg = json.loads(log_msg)</span><br><span class="line">    print(log_msg[<span class="string">'loginMsg'</span>])</span><br><span class="line">    <span class="comment"># UserLoadingAction</span></span><br><span class="line">    headers[<span class="string">'cookie'</span>] = full_cookie</span><br><span class="line">    data_loading = &#123;</span><br><span class="line">        <span class="string">'loginMsg'</span>: log_msg[<span class="string">'loginMsg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.post(user_loading_url, data=data_loading, headers=headers)</span><br></pre></td></tr></table></figure>
<p>查看res，会提示登录成功，这时在访问课表的网址，就正常返回了课表</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>正确的Header和Cookie很重要</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学校 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
