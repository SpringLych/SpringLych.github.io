<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发学习-三]]></title>
    <url>%2F2019%2F03%2F28%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[线程状态转换和线程状态基本操作]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习-二]]></title>
    <url>%2F2019%2F03%2F28%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java内存模型 Java内存模型线程安全问题。《深入理解Java虚拟机》定义，当多个线程访问同一个对象，如果不考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确结果，藏鞥对象是线程安全的。 出现线程安全的原因一般是 主内存和工作内存数据不一致和重排序导致。 Java内存模型 并发编程两个关键问题：线程之间如何通信，线程之间如何同步。 两种通信机制：共享内存，消息传递 共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。 消息传递：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。 Java并发采用共享内存。 Java线程之间的通信有Java内存模型（JMM）控制，他决定了一个线程的共享变量的写入何时对另一个线程可见。 从抽象角度：JMM定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每个线程都有一个私有本地内存，本地内存中存储了该线程共享变量的副本。本地内存并不真实存在。 两个线程，A和B通信，经历步骤： 线程A将本地内存A中更新过的共享变量刷新到主内存中 线程B到主内存中读取A更新过得变量。 内存模型三大特性三大特性：原子性，可见性，有序性 原子性即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1`i = ``9``;` 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 可见性可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 有序性有序性指，在本线程内观察，所有操作都是有序的，在一个线程观察另一个线程，所有操作都是无序的。无序是因为发生了指令重排序。在Java内存模型，允许编译器和处理器对指令进行重排序，重排序不会影响单线程程序的执行，会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 重排序为提高性能，编译器处理器对指令进行重排序，分为三种： 编译器优化 指令级并行 内存系统 针对编译器重排序，JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序。 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序 参考 全面理解Java内存模型(JMM)及volatile关键字 全面理解Java内存模型 Java-并发-Java内存模型 Java内存模型和JVM内存管理 掘金-Java内存模型以及happens-before规则]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F03%2F28%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[整理一些常用的git命令 本地push到远程初始化本地 1git init 本地关联远程 1git remote add origin git@gitres 添加和提交 12git add .git commit -m "注释" push 远程 1234第一次推送master分支时，加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，git push -u origin mastergit push origin master 文件操作添加文件目录1234# 添加当前目录所有文件到暂存区git add .git add [file1] [file2]...git add [dir] 撤销add1git rm --cached &lt;file&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习-一]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java创建线程，线程常用函数 创建线程三种方式：继承Thread类重写run方法，实现Runnable接口，实现callable接口。 继承Thread类重写run方法123456789101112131415161718192021222324252627282930class Thread1 extends Thread &#123; private String name; private int ticket = 20; private Random rand = ThreadLocalRandom.current(); public Thread1(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(name + "运行：" + i); &#125; try &#123; sleep(rand.nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class Demo extends Thread &#123; public static void main(String[] args) &#123; Thread1 thread1 = new Thread1("A"); Thread1 thread2 = new Thread1("B"); thread1.start(); thread2.start(); &#125;&#125; 实现Runnable接口1234567891011121314151617181920212223242526272829class DemoByRun implements Runnable &#123; private String name; public DemoByRun(String name) &#123; this.name = name; &#125; private Random random = ThreadLocalRandom.current(); @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(name + "运行：" + i); &#125; try &#123; Thread.sleep(random.nextInt(50)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; new Thread(new DemoByRun("A")).start(); new Thread(new DemoByRun("B")).start(); &#125;&#125; 实现callable接口123456789101112131415public class Main5 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; DemoByCallable call = new DemoByCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(call); new Thread(futureTask).start(); System.out.println(futureTask.get()); &#125;&#125;class DemoByCallable implements Callable&lt;String&gt; &#123; @Override public String call() &#123; return "hello"; &#125;&#125; 比较实现Runnable接口比继承Thread类所具有的优势： 1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 两者都有的： 适合多个相同的程序代码的线程去处理同一个资源增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 线程常用函数start与run区别start()是启动一个新线程。通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法， start() 可以启动一个新线程，run()不能 start()不能被重复调用，run()可以 start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。 start() 实现了多线程，run()没有实现多线程。 setPriority(): 更改线程的优先级。 MIN_PRIORITY = 1NORM_PRIORITY = 5MAX_PRIORITY = 10 Join()为什么要用join()方法在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"主线程运行开始!"); Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); try &#123; mTh1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; mTh2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "主线程运行结束!"); &#125;&#125; yield():暂停当前正在执行的线程对象，并执行其他线程。 yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。 sleep()和yield()的区别 sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 wait()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyThreadPrint extends Thread &#123; private String name; private final Object prev; private final Object self; private MyThreadPrint(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.println(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Object A = new Object(); Object B = new Object(); Object C = new Object(); MyThreadPrint myA = new MyThreadPrint("A", C, A); MyThreadPrint myB = new MyThreadPrint("B", A, B); MyThreadPrint myC = new MyThreadPrint("C", B, C); try &#123; new Thread(myA).start(); Thread.sleep(100); new Thread(myB).start(); Thread.sleep(100); new Thread(myC).start(); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。 一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。 wait和sleep区别共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。不同点： Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 所以sleep()和wait()方法的最大区别是： sleep()睡眠时，保持对象锁，仍然占有该锁； 而wait()睡眠时，释放对象锁。 但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。 参考Java多线程学习（吐血超详细总结） Java多线程基础学习]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose收集]]></title>
    <url>%2F2019%2F03%2F26%2Fdocker-compose%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[自己写的，收集整理的一些docker-compose.yml Aria2一个多线程下载器，可由网页端管理 123456789101112131415version: '2'services: aria2: image: wahyd4/aria2-ui container_name: aria2 ports: - "6810:80" - "6800:6800" volumes: - /usr/conf/aria2:/root/conf - /media/download/aria2:/var/www:rw #- /usr/data/aria2:/var/www:rw environment: - DOMAIN=:80 restart: always MongoDB123456789101112131415version: '3.1'services: mongo: image: mongo container_name: mongodb restart: always environment: MONGO_INITDB_ROOT_USERNAME: username MONGO_INITDB_ROOT_PASSWORD: password ports: - "27017:27017" volumes: - /usr/data/mongodb:/data/db Redis1234567891011version: '2'services: redis: image: redis container_name: redis ports: - 6379:6379 volumes: - /usr/conf/redis/redis.conf:/usr/local/etc/redis/redis.conf - /usr/conf/redis/data:/data restart: unless-stopped]]></content>
      <categories>
        <category>docker-compose</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[保证一个类只有一个实例，提供一个访问他的全局访问点 多种实现1. 饿汉模式12345678910public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。一般情况下使用。 2. 懒汉模式(线程不安全)12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例 3. 懒汉模式 （线程安全）123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125; 使用 synchronized,每次调用getInstance方法时都需要进行同步，造成不必要的同步开销， 4. 双重检查模式（DCL）1234567891011121314public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检验锁模式（double checked locking pattern） 5. 静态内部类单例模式（推荐）1234567891011public class Singleton &#123; private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCEE = new Singleton(); &#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCEE; &#125;&#125; 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 6. 枚举类（最佳）123public enum EasySingleton&#123; INSTANCE;&#125; 实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 总结一般情况下使用第一种 饿汉模式，明确要求要懒加载（lazy initialization），使用第五种静态内部类。涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。 参考 如何正确地写出单例模式 设计模式（二）单例模式的七种写法 菜鸟教程-单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-笔记]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《深入理解Java虚拟机》读书笔记 Java运行时数据区分为：程序计数器，Java虚拟机栈，本地方法区，Java堆，方法区 程序计数器，Java虚拟机，本地方法区是线程私有，随线程而生，随线程而灭。 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空），分支，跳转，异常处理都需要计数器完成。 Java虚拟机栈每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等信息。每一个方法从调用到执行完成的过程，对应一个栈帧在虚拟机中入栈到出栈的过程。 异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈为虚拟机使用到的Native方法服务。 异常： StackOverError， OutOfMemoryError Java堆被所有线程共享。存放对象实例，是垃圾收集器管理的主要区域，“GC堆”。 异常： OutOfMemoryError 方法区线程共享。存放被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。具备动态性。 直接内存在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。 垃圾收集主要针对堆和方法区。 判断对象是否可回收引用计数法为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 目前主流Java虚拟机没有使用这种方法。 可达性分析算法以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 可作为GC Roots的对象： 虚拟机栈引用的对象 方法区静态属性引用对象 常量引用的对象 本地方法栈中引用的对象 引用类型 强引用 强引用的对象不会被回收。 1Object obj = new Object(); 软引用 有用但非必须的对象。在内存不够的情况下被回收。 弱引用 一定会被回收。 虚引用 又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 回收过程一个对象死亡经历两次标记过程。第一次，使用可达性分析算法标记，判断对象是否需要执行finalize()方法，如果有必要执行，被一个低优先级的Finalizer线程执行。finalize()方法是对象逃脱死亡的最后一次机会。如果对象在finalize()中没有重新与引用链上任何一个对象建立关联，则会被回收。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 方法区的回收方法区主要存放永久代对象。主要是对常量池的回收和对类的卸载。 类卸载条件： 该类所有的实例已经被回收，Java堆中不存在该类的任何实例 加载该类的CladdLoader被回收。 该类对应的java.lang.Class对象没有在任何地方被引用 垃圾收集算法标记-清除算法两个阶段：标记，清除。首先标记所有需要回收的对象，标记完成统一回收。 不足： 标记和清除效率都不高 标记清除后会产生大量不连续的内存碎片 复制算法将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 不足为只用内存的一半 使用该算法收集新生代 标记-整理算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法将Java堆分为新生代和老年代。新生代选用复制算法，老年代使用：标记-清除或者标记-整理算法。 垃圾收集器 1. Serial 收集器单线程收集器，进行垃圾收集时，必须暂停其他所有线程。 优点：简单高效，单个CPU环境，单线程收集效率高。 是Client模式下默认的新生代收集器。 2. ParNew 收集器Serial收集器的多线程版。 Server模式下虚拟机的默认新生代收集器。 3. Parallel Scavenge 收集器使用复制算法，多线程。 其他收集器关注点是尽量缩短垃圾收集时用户线程的停顿时间，它的目的是达到一个可控的吞吐量。 4. Serial Old 收集器Serial收集器的老年代版本，单线程，使用 标记-整理算法 Srver场景： 作为CMS收集器的后备 JDK1.5 前与 Parallel Scavenge收集器搭配 5. Parallel Old 收集器Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS收集器基于 标记-清除算法 流程： 初始标记：标记GC Roots能直接关联到的对象，速度快。需要Stop The World 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要Stop The World 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 优点：并发收集，低停顿 缺点： 对CPU资源敏感，因此吞吐量低 无法处理浮动垃圾， 标记 - 清除算法导致的空间碎片 7. G1 收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 特点： 并行与并发：使用多个CPU缩短 STW的时间 分代收集： 空间整合：整体使用 标记-整理 算法，局部使用复制算法 可预测的停顿 收集范围是整个Java堆，把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 内存分配与回收策略Minor GC 和 Full GC Minor GC：发生在新生代的垃圾收集，频繁，回收速度快 Full GC：发生在老年代的垃圾收集。伴随着至少一次的Minor GC，速度慢。 内存分配1. 对象优先在Eden分配大多数情况下，对象优先在新生代Eden分配。当Eden空间不够时，发起Minor GC。 2. 大对象直接进入老年代最典型的大对象是那种很长的字符串以及数组。 3. 长期存活对象直接进入老年代对象在Eden出生并经历第一次Minor GC后任然存活，并能被Survivor接受，将被移动到Survivor空间，对象年龄为1,。对象在Survivor区每熬过一次，Minor GC，年龄增加一岁，增加到（默认15岁）被晋升到老年代中。 年龄阈值通过-XX:PretenureSizeThreshold设定 4. 动态对象年龄判定如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年两大于等于改年龄的对象直接进入老年代。 5. 空间分配担保出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，Survivor空间无法容纳的对象直接进入老年代。 类加载机制类与类加载器比较两个类是否相等，只有在两个类有同一个类加载器加载的前提下才有意义，否则，即使这两个类来自于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，这连个类必定不相等。 类加载器分类 启动类加载器 扩展类加载器 应用程序类加载器 双亲委派模型 双亲委派模型要求，除了顶层的启动类加载器，其他加载器都应该有自己的父类加载器。类加载器以组合的关系复用父加载器。 工作过程如果一个类加载器收到了类加载请求，它首先不会加载这个类，而是把这个请求委派给父类加载器完成，每一层次都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求，子加载器才会尝试自己加载。 好处Java类随着他的加载器有了带有优先级的层次关系。例如 java.lang.Object 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2017. CS-Notes-Java 虚拟机]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西南交大教务模拟登陆]]></title>
    <url>%2F2019%2F01%2F29%2F%E8%A5%BF%E5%8D%97%E4%BA%A4%E5%A4%A7%E6%95%99%E5%8A%A1%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[最近由于需要做一个获取学生课表的项目，就去研究了下如何模拟登录，并用Python成功模拟登录。在此记录一下自己的分析过程。 登录分析使用Chrome登录教务网，打开调试模式，使用NetWork记录点击“登录按钮”后发生的过程 点击登录后浏览器请求的地址为http://dean.vatuu.com/vatuu/UserLoginAction，这就是我们需要记录的一个url，模拟登录时就向改网址发送请求； 我们需要重点分析Header和cookie。查看Response Header，该网址返回的Header信息有个Set-Cookie字段；在Request-Headers中，有一个JSESSIONID UserLoadingAction是登录成功后跳转的一个页面。查看Request Header中的Cookie为学号+JSESSIONID，因此明白JSESSIONID以及如何获取它至关重要。 另一个问题就是验证码，我采用人工输入的方式。审查元素，查看验证码的接口，得到其地址。 复制这个地址，粘贴到地址栏，得到验证码。 我猜想验证码和JSESSIONID有很大关系。退出教务登录，打开调试工具的“Application-Cookies”可以看到保存的Cookie，清除 刷新验证码地址，可以看到会再次出现JSESSIONID 因此可以假设通过验证码获取JSESSIONDI 使用Python尝试登录123456789101112def get_jsessionid(): """ 访问登录界面，通过Response Header用于获取set-cookie """ s = requests.Session() r = s.get(get_photo_url) with open('./static/ranstring.jpg', 'wb') as file: file.write(r.content) get_head = r.headers set_cookie = str(get_head['Set-Cookie']) jessid = set_cookie.split(';')[0] return jessid 运行后，可以看到获取到了JSESSIONID。 之后模拟登录。 123456789101112131415161718jsessionid = get_jsessionid()full_cookie = 'username='+str(data['username'])+'; ' + str(jsessionid)log_msg = ""def login(): """ 登录 """ # 登录需要的cookie只有jsessionid headers['cookie'] = jsessionid data['ranstring'] = input("验证码：") # UserLoginAction res = requests.post( user_log_url, data, headers=headers, allow_redirects=True) log_msg = res.text log_msg = json.loads(log_msg) print(log_msg['loginMsg']) 看到出现教务返回的登录成功等字样就表示登录成功。 尝试获取课表时，却提示未登录。我认为UserLoadingAction这一步也是必须的。 再次分析 查看UserLoadingAction，发现向它传送的数据中有一个“loginMsg”字段，这正是点击‘’登录系统“成功后返回的字段的一部分 在登录时访问UserLoadingAction查看是否生效 123456789101112131415161718192021def login(): """ 登录 两步：UserLoginAction + UserLoadingAction """ headers['cookie'] = jsessionid data['ranstring'] = input("验证码：") # UserLoginAction res = requests.post( user_log_url, data, headers=headers, allow_redirects=True) # with open('./response.html') as file: # file.writer(response.text) log_msg = res.text log_msg = json.loads(log_msg) print(log_msg['loginMsg']) # UserLoadingAction headers['cookie'] = full_cookie data_loading = &#123; 'loginMsg': log_msg['loginMsg'] &#125; res = requests.post(user_loading_url, data=data_loading, headers=headers) 查看res，会提示登录成功，这时在访问课表的网址，就正常返回了课表 总结 正确的Header和Cookie很重要]]></content>
      <categories>
        <category>学校</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
