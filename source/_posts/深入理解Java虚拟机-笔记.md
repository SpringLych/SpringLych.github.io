---
title: 深入理解Java虚拟机
date: 2019-03-22 19:17:27
tags: [Java,JVM]
categories: Java
---

《深入理解Java虚拟机》读书笔记，以及其他关于JVM的一些博客

<!--more-->	

## Java运行时数据区

分为：程序计数器，Java虚拟机栈，本地方法区，Java堆，方法区

程序计数器，Java虚拟机，本地方法区是线程私有，随线程而生，随线程而灭。

### 程序计数器
记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空），分支，跳转，异常处理都需要计数器完成。
### Java虚拟机栈
每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等信息。每一个方法从调用到执行完成的过程，对应一个栈帧在虚拟机中入栈到出栈的过程。

异常：
* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
* 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

### 本地方法栈
为虚拟机使用到的Native方法服务。

异常：
* StackOverError，
* OutOfMemoryError

### Java堆
被所有线程共享。存放对象实例，是垃圾收集器管理的主要区域，“GC堆”。

异常：
* OutOfMemoryError

### 方法区
线程共享。存放被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

### 运行时常量池
是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。具备动态性。

### 直接内存
在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。

## 对象-new一个对象的过程

1. 类加载检查。首先检查new指令的参数能否在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否加载完成，如果没有，执行相应的类加载过程。
2. 为新生对象分配内存。对象所需内存大小在类加载完成后已经确定
3. 内存分配完，将分配到的内存空间初始化为零值
4. 对对象进行必要的设置，如该对象是哪个类的实例等
5. 执行init方法，将对象按照程序员意愿初始化对象。（如 private int age = 10）

## 垃圾收集

主要针对堆和方法区。

### 判断对象是否可回收

#### 引用计数法

为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

目前主流Java虚拟机没有使用这种方法。

#### 可达性分析算法

以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

可作为GC Roots的对象：

* 虚拟机栈引用的对象
* 方法区静态属性引用对象
* 常量引用的对象
* 本地方法栈中引用的对象

#### 引用类型

*  强引用

强引用的对象不会被回收。

```java
Object obj = new Object();
```

* 软引用

有用但非必须的对象。在内存不够的情况下被回收。

* 弱引用

一定会被回收。

* 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

#### 回收过程

一个对象死亡经历两次标记过程。第一次，使用可达性分析算法标记，判断对象是否需要执行`finalize()`方法，如果有必要执行，被一个低优先级的Finalizer线程执行。`finalize()`方法是对象逃脱死亡的最后一次机会。如果对象在`finalize()`中没有重新与引用链上任何一个对象建立关联，则会被回收。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。任何一个对象的`finalize()`只会被系统自动调用一次

#### 方法区的回收

方法区主要存放永久代对象。主要是对常量池的回收和对类的卸载。

类卸载条件：

* 该类所有的实例已经被回收，Java堆中不存在该类的任何实例
* 加载该类的CladdLoader被回收。
* 该类对应的java.lang.Class对象没有在任何地方被引用

### 垃圾收集算法

#### 标记-清除算法

两个阶段：标记，清除。首先标记所有需要回收的对象，标记完成统一回收。

不足：

* 标记和清除效率都不高
* 标记清除后会产生大量不连续的内存碎片

#### 复制算法

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

实现简单，运行高效。不足为只用内存的一半

使用该算法收集新生代

#### 标记-整理算法

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

将Java堆分为新生代和老年代。新生代选用复制算法，老年代使用：标记-清除或者标记-整理算法。

### HotSpot算法实现

GC进行时必须停顿所有Java执行线程，即**STW(Stop The World)**。

程序执行时只有在安全点才能发生GC。

### 垃圾收集器

![](garbaecollection.jpg)

#### 1. Serial 收集器

**单线程收集器**，进行垃圾收集时，必须暂停其他所有线程。

优点：简单高效，单个CPU环境，单线程收集效率高。

是Client模式下默认的新生代收集器。

#### 2. ParNew 收集器

Serial收集器的**多线程**版。

Server模式下虚拟机的默认新生代收集器。

#### 3. Parallel Scavenge 收集器

使用**复制算法**，多线程。

其他收集器关注点是尽量缩短垃圾收集时用户线程的停顿时间，它的目的是达到一个可控的**吞吐量**。

#### 4. Serial Old 收集器

Serial收集器的老年代版本，**单线程**，使用 **标记-整理算法**

Srver场景：

* 作为CMS收集器的后备
* JDK1.5 前与 Parallel Scavenge收集器搭配

#### 5. Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

#### 6. CMS收集器

基于 **标记-清除算法**

流程：

* 初始标记：标记GC Roots能直接关联到的对象，速度快。需要**Stop The World**
* 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长
* 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要**Stop The World**
* 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

优点：并发收集，低停顿

缺点：

* 对CPU资源敏感，因此吞吐量低
* 无法处理浮动垃圾，
* 标记 - 清除算法导致的空间碎片

#### 7. G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

相比于CMS，G1的优势在于：没有向CMS的碎片化问题，提供可控的停顿时间。G1设计的目的：尽力满足停顿桑蝉爱你



特点：

* 并行与并发：使用多个CPU缩短 STW的时间
* 分代收集：
* 空间整合：整体使用 **标记-整理 算法**，局部使用**复制算法**
* 可预测的停顿

收集范围是整个Java堆，把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 

步骤：

* 初始标记
* 并发标记
* 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
* 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

## 内存分配与回收策略

### Minor GC 和 Full GC

* Minor GC：发生在新生代的垃圾收集，频繁，回收速度快
* Full GC：发生在老年代的垃圾收集。伴随着至少一次的Minor GC，速度慢。

### 内存分配

#### 1. 对象优先在Eden分配

大多数情况下，对象优先在新生代Eden分配。当Eden空间不够时，发起Minor GC。

#### 2. 大对象直接进入老年代

最典型的大对象是那种很长的字符串以及数组。

通过`-XX:PretenureSizeThreshold`参数，大于这个设置值的对象直接在老年代分配。避免在Eden曲和两个Survivor区发生大量内存复制。

#### 3. 长期存活对象直接进入老年代

对象在Eden出生并经历第一次Minor GC后任然存活，并能被Survivor接受，将被移动到Survivor空间，对象年龄为1,。对象在Survivor区每熬过一次，Minor GC，年龄增加一岁，增加到（默认15岁）被晋升到老年代中。

年龄阈值通过`-XX:PretenureSizeThreshold`设定

#### 4. 动态对象年龄判定

如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年两大于等于改年龄的对象直接进入老年代。

#### 5. 空间分配担保

出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，Survivor空间无法容纳的对象直接进入老年代。

## 类加载机制

### 类与类加载器

比较两个类是否相等，只有在两个类有同一个类加载器加载的前提下才有意义，否则，即使这两个类来自于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，这连个类必定不相等。

### 类加载器分类

* 启动类加载器
* 扩展类加载器
* 应用程序类加载器

### 双亲委派模型

![](双亲委派模型.png)

双亲委派模型要求，除了顶层的启动类加载器，其他加载器都应该有自己的父类加载器。类加载器以组合的关系复用父加载器。

#### 工作过程

如果一个类加载器收到了类加载请求，它首先不会加载这个类，而是把这个请求委派给父类加载器完成，每一层次都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求，子加载器才会尝试自己加载。

#### 好处

Java类随着他的加载器有了带有优先级的层次关系。例如 `java.lang.Object`

## 参考资料

* 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2017.
* [CS-Notes-Java 虚拟机](<https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md>)
* [Javadoop - HotSpot JVM 内存管理](<https://www.javadoop.com/post/jvm-memory-management>)
* 