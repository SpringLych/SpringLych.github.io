---
title: 设计模式-结构型
date: 2019-04-15 20:15:08
tags: 设计模式
categories: 设计模式
---

设计模式中结构型模式。结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。

主要包括代理模式（Proxy Pattern），适配器模式（Adapter Pattern），桥接（Bridge），装饰器模式（Decorator Pattern），外观模式（Facade Pattern），组合模式（Composite Pattern），享元模式。

<!--more-->

# 1. 代理模式（Proxy Pattern）

代理模式（Proxy Pattern）中，一个类代表另一个类的功能。

Spring框架的AOP就是代理模式的体现。

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

```java
public interface FoodService{
    Food makeChicken();
    Food makeNoodle();
}

public class FoodServiceImpl implements FoodService{
    public Food makechicken(){
        Food f = new Chicken();
        f.setChicken("aa");
        f.setSpicy("bb");
        return f;
    }

    public Food makeNoodle(){
        Food f = new Noodle();
        f.setNoodle("aa");
        f.setSalt("bb");
        return f;
    }
}

public class FoodServiceProxy implements FoodService{
    private FoodService foodService = new FoodServiceImpl();

    public Food makeChicken(){
        // 制作chicken
        Food food = foodService.makeChicken();
        // chicken制作完成
        food.addCondiment("add");
        return food;
    }
}
```

![](proxy-1.png)

代理模式说白了就是做 **“方法包装”** 或做 **“方法增强”**。AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。

## JDK

* [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29)
* [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
* [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
* [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)

# 2. 适配器模式（Adapter Pattern）

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。

```java
public interface Duck {
    public void quack();// 鸭叫
    public void fly();
}

public interface Cock {
    public void gobble();// 鸡叫
    public void fly();
}

public class WildCock implements Cock{
    public void gobble(){
        System.out.println("鸡叫");;
    }
    public void fly(){
        System.out.println("鸡飞");
    }
}

```

使用适配器模式，让鸭实现鸡叫

```java
public class CockAdapter implements Duck{
    Cock cock;
    public CockAdapter(Cock cock) {
        this.cock = cock;
    }

    @Override
    public void quack(){
        // 鸡叫
        cock.gobble();
    }
}
```

![](adapter-2.png)

# 3. 桥梁模式（Bridge）

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。



首先定义桥梁，接口，定义提供的接口方法

```java
public interface DrawApi{
    public void draw(int radius, int x, int y);
}
```

实现类

```java
public class RedPen implements DrawApi{
    @Override
    public void draw(int radius, int x, int y){
         System.out.println("用红色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);
    }
}
public class GreenPen implements DrawAPI {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println("用绿色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);
   }
}
```

定义抽象类

```java
public abstract class Shape {
   protected DrawAPI drawAPI;

   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();    
}
```

```java
// 长方形
public class Rectangle extends Shape {
    private int x;
      private int y;

      public Rectangle(int x, int y, DrawAPI drawAPI) {
        super(drawAPI);
          this.x = x;
          this.y = y;
    }
      public void draw() {
      drawAPI.draw(0, x, y);
   }
}
```

```java
public static void main(String[] args) {
      Shape redRectangle = new Rectangle(4, 8, new RedPen());
      redRectangle.draw();
}
```

![](bridge-1.png)

## JDK

* AWT
* JDBC

# 4. 装饰模式（Decorator Pattern）

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。

**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

```java
/**
 * 定义基本饮料类
 */
public abstract class Beverage{
    public abstract String getDesc();
    public abstract double price();
}
```

添加三个饮料实现红茶， 绿茶

```java
public class BlackTea extends Beverage{
    @Override
    public String getDesc() {
        return "红茶";
    }

    @Override
    public double price() {
        return 11;
    }
}

public class GreenTea extends Beverage{
    @Override
    public String getDesc() {
        return "绿茶";
    }

    @Override
    public double price() {
        return 22;
    }
}
```

调料，即装饰器的基类，继承自Beverage

```java
// 调料
public abstract class Condiment extends Beverage{
    
}
```

定义具体调料

```java
public class Lemon extends Condiment{
    // 
    private Beverage beverage;

    // 传入具体饮料
    public Lemon(Beverage beverage){
        this.beverage = beverage;
    }

    @Override
    public String getDesc() {
        // 装饰
        return beverage.getDesc() + " 加柠檬";
    }
}

public class Mango extends Condiment {
    private Beverage bevarage;
      public Mango(Beverage bevarage) {
        this.bevarage = bevarage;
    }
      public String getDescription() {
        return bevarage.getDescription() + ", 加芒果";
    }
      public double cost() {
        return beverage.cost() + 3; // 加芒果需要 3 元
    }
}
```

客户端

```java
public static void main(String[] args) {
      // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡
    Beverage beverage = new GreenTea();
      // 开始装饰
      beverage = new Lemon(beverage); // 先加一份柠檬
      beverage = new Mongo(beverage); // 再加一份芒果

      System.out.println(beverage.getDescription() + " 价格：￥" + beverage.cost());
      //"绿茶, 加柠檬, 加芒果 价格：￥16"
}
```

![](decorator.jpg)

## JDK

* java.io.BufferedInputStream(InputStream)

* java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes)

![](decorator-3.png)

# 5. 外观模式（Facade Pattern）

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

创建接口，和实现类

```java
public interface Shape{
    void draw();
}

public class Circle implements Shape{
    @Override
    public void draw(){
        System.out.println("Circle draw");
    }
}

public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}
```

创建外观类

```java
public class ShapeMaker{
    private Shape circle;
    private Shape square;
    
     public ShapeMaker() {
      circle = new Circle();
      square = new Square();
   }
    
    public void drawCircle(){
      circle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
```

客户端

```java
public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();

    shapeMaker.drawCircle();
    shapeMaker.drawSquare();      
}
```

# 6. 组合模式（Composite Pattern）

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。

```java
public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates; // 下属

   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List<Employee> getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return ("Employee :[ Name : " + name + ", dept : " + dept + ", salary :" + salary+" ]");
   }   
}
```

## JDK

* javax.swing.JComponent#add(Component)
* java.awt.Container#add(Component)
* java.util.Map#putAll(Map)
* java.util.List#addAll(Collection)
* java.util.Set#addAll(Collection)



# 7. 享元模式

## JDK

Java 利用缓存来加速大量小对象的访问时间。

* java.lang.Integer#valueOf(int)
* java.lang.Boolean#valueOf(boolean)
* java.lang.Byte#valueOf(byte)
* java.lang.Character#valueOf(char)



# 参考

* [Javadoop - 设计模式也可以这么简单](<https://www.javadoop.com/post/design-pattern>)
* [CS-Notes - 设计模式](<https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md>)
* [菜鸟教程 - 设计模式](<http://www.runoob.com/design-pattern/design-pattern-tutorial.html>)