---
title: Java并发学习-二
date: 2019-03-28 14:24:58
tags: [Java,并发]
categories: Java
---

Java内存模型，volatile关键字

<!--more-->

## Java内存模型

线程安全问题。《深入理解Java虚拟机》定义，当多个线程访问同一个对象，如果不考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确结果，藏鞥对象是线程安全的。

出现线程安全的原因一般是 主内存和工作内存数据不一致和重排序导致。

### Java内存模型

* 并发编程两个关键问题：
  线程之间如何通信，线程之间如何同步。
* 两种通信机制：共享内存，消息传递
  * 共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过**共享对象**进行通信。
  * 消息传递：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是**wait()**和**notify()**。

Java并发采用共享内存。  

Java线程之间的通信有Java内存模型（JMM）控制，他决定了一个线程的共享变量的写入何时对另一个线程可见。

从抽象角度：JMM定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每个线程都有一个私有本地内存，本地内存中存储了该线程共享变量的副本。本地内存并不真实存在。

![](20160921182337904)

两个线程，A和B通信，经历步骤：
1. 线程A将本地内存A中更新过的共享变量刷新到主内存中
2. 线程B到主内存中读取A更新过得变量。

### 内存模型三大特性

三大特性：原子性，可见性，有序性

#### 原子性

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？

```
`i = ``9``;`
```

 　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。

　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。

#### 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

主要有三种实现可见性的方式：

* volatile
* synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
* final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

#### 有序性

有序性指，在本线程内观察，所有操作都是有序的，在一个线程观察另一个线程，所有操作都是无序的。无序是因为发生了**指令重排序**。在Java内存模型，允许编译器和处理器对指令进行重排序，重排序不会影响单线程程序的执行，会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

### 重排序

为提高性能，编译器处理器对指令进行重排序，分为三种：

* 编译器优化
* 指令级并行
* 内存系统

**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。

**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序**

## volatile关键字

两个作用：

* 保证volatile修饰的变量对所有线程可见
* 禁止指令重排序优化

**volatile**关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。

使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， **volatile不能保证复合操作的原子性**，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

**实现方式**：写一个volatile变量时，JMM将线程对应的工作内存中共享变量刷新到主内存中，读取volatile变量，JMM将该线程对应的工作内存设置为无效，该线程从主内存中读取更像变量。

volatile自身变量具有特性：

* 可见性。对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。
* 原子性。对任意单个volatile变量的读/写具有原子性，但i++不具有。

## 参考

* [全面理解Java内存模型(JMM)及volatile关键字](https://blog.csdn.net/javazejian/article/details/72772461)  
* [全面理解Java内存模型](https://blog.csdn.net/suifeng3051/article/details/52611310)
* [Java-并发-Java内存模型](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
* [Java内存模型和JVM内存管理](https://www.cnblogs.com/yjd_hycf_space/p/7505372.html)
* [掘金-Java内存模型以及happens-before规则](https://juejin.im/post/5ae6d309518825673123fd0e)