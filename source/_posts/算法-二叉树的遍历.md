---
title: 二叉树的遍历-算法
date: 2019-07-12 19:10:58
tags: [算法, 二叉树]
categories: 算法
---

二叉树的先中后遍历的递归与非递归实现，层序遍历，Mirros遍历

<!--more-->

## 先序遍历

[LeetCode-144. Binary Tree Preorder Traversal](<https://leetcode.com/problems/binary-tree-preorder-traversal/>)

### 递归实现

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        preOrderHelp(res, root);
        return res;
    }
    
    private void preOrderHelp(List<Integer> res, TreeNode root){
        if(root == null) return;
        res.add(root.val);
        preOrderHelp(res, root.left);
        preOrderHelp(res, root.right);
    }
}
```

### 非递归实现

使用栈保存节点。注意入栈时是**右孩子先入栈**。

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        TreeNode node = null;
        while(!stack.isEmpty()){
            node = stack.pop();
            if(node != null){
                res.add(node.val);
                stack.push(node.right);
                stack.push(node.left);
            }
        }
        return res;
    }
}
```

### 非递归实现2

不需要入栈，每次遍历到“左”节点，立即输出即可。

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        TreeNode cur = root;
        Stack<TreeNode> stack = new Stack<>();
        while(cur != null || !stack.empty()){
            while(cur != null){
                res.add(cur.val);
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            cur = cur.right;
        }
        return res;
    }
}
```

## 中序遍历

[LeetCode - 94. Binary Tree Inorder Traversal](<https://leetcode.com/problems/binary-tree-inorder-traversal/description/>)

### 递归实现

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        inorderHelp(res, root);
        return res;
    }
    
    private void inorderHelp(List<Integer> res, TreeNode root){
        if(root == null) return;
        inorderHelp(res, root.left);
        res.add(root.val);
        inorderHelp(res, root.right);
    }
}
```

### 非递归实现

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        TreeNode cur = root;
        Stack<TreeNode> stack = new Stack<>();
        while(cur != null || !stack.isEmpty()){
            while(cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            res.add(cur.val);
            cur = cur.right;
        }
        return res;
    }
}
```

## 后序遍历

[LeetCode - 145. Binary Tree Postorder Traversal]()

### 递归

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        postorderHelp(res, root);
        return res;
    }
    
     private void postorderHelp(List<Integer> res, TreeNode root){
        if(root == null) return;
        postorderHelp(res, root.left);
        postorderHelp(res, root.right);
         res.add(root.val);
    }
}
```

### 非递归

```java

```



## 层序遍历

[newcoder - 从上往下打印二叉树](<https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

[LeetCode - 102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

使用队列作为辅助结构

```java
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        TreeNode node = null;
        while(!queue.isEmpty()){
            node = queue.poll();
            res.add(node.val);
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
        return res;
    }
}
```

## Morris遍历

Morris遍历可以在O(N)的时间复杂度内完成遍历，且空间复杂度为O(1)，N：二叉树节点个数。其遍历规则为：

1. 当前节点cur，如果cur无左孩子，cur右移（cur = cur.right）
2. 如果cur 有左孩子，找到cur左子树最右的节点，记为mostright。
   1. 如果mostright的right指向空，让其指向cur，cur 左移（cur = cur.left）
   2. 如果mostright的right指向cur，让其指向空，cur 右移

```java
public void mirros(TreeNode root){
    if(root == null) return;
    TreeNode cur = root;
    TreeNode mostRight = null;
    while(cur != null){
        mostRight = cur.left;
        if(mostRight != null){
            while(mostRight.right != null && mostRight.right != cur){
                mostRight = mostRight.right;
            }
            if(mostRight.right == null){
                mostRight.right = cur;
                cur = cur.left;
                continue;
            }else{
                mostRight.right = null;
            }
        }
        cur = cur.right;
    }
}
```

### 先序遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        TreeNode cur = root;
        TreeNode mostRight = null;
        while(cur != null){
            mostRight = cur.left;
            if(mostRight != null){
                while(mostRight.right != null && mostRight.right != cur){
                    mostRight = mostRight.right;
                }
                if(mostRight.right == null){
                    mostRight.right = cur;
                    // 先序
                    res.add(cur.val);
                    cur = cur.left;
                    continue;
                }else{
                    mostRight.right = null;
                }
            }else{// 先序
                res.add(cur.val);
            }
            cur = cur.right;
        }
        return res;
    }
}
```

### 中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        TreeNode cur = root;
        TreeNode most = null;
        while(cur != null){
            most = cur.left;
            if(most != null){
                while(most.right != null && most.right != cur){
                    most = most.right;
                }
                if(most.right == null){
                    most.right = cur;
                    cur = cur.left;
                    continue;
                }else{
                    most.right = null;
                }
            }
            // 中序
            res.add(cur.val);
            cur = cur.right;
        }
        return res;
    }
}
```



## 参考

* [掘金 - 刷题二叉树非递归遍历](<https://juejin.im/post/59e3fde451882578c20858a5>)