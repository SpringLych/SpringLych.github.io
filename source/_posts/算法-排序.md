---
title: 算法-排序
date: 2019-04-11 14:28:06
tags: [算法, 排序]
categories: [算法]
---

整理常用排序算法。

<!--more-->

# 约定

将排序代码放在 sort()方法中。待排序元素实现Comparable接口。

```java
public abstract class BaseSort<T extends Comparable<T>> {

    /**
     * 排序代码
     *
     * @param array 排序数组
     */
    public abstract void sort(T[] array);

    /**
     * 判断前一个元素是否小于后一个元素
     */
    protected boolean less(T a, T b) {
        return a.compareTo(b) < 0;
    }

    /**
     * 交换数组中两个元素
     */
    protected void swap(T[] nums, int i, int j) {
        T temp = nums[i];
        nums[i] = nums[j];
        nums[j] = nums[i];
    }
}
```



# 选择排序

## 描述

首先找到数组中最小的那个元素，然后将它和数组中第一个元素交换位置（第一个元素就是最小元素就和自己交换）。之后在剩下的元素中找到最小元素，将它和数组第二位置元素交换位置。知道整个数组有序。它在不断选在剩余元素中的最小者。

选择排序需要  N^2 / 2次比较和 N 次交换。它的运行时间和输入无关。数据移动是最少的。

该算法将第 i 小的元素放在第 i 个位置，i左边的元素不会再被访问。

时间复杂度：O(N^2)。空间复杂度O(1)。排序稳定。

## 动图

![](selection.gif)

## 代码

```java
public class Selection<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] array) {
        int len = array.length;
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                int min = i;
                if (less(array[j], array[min]))
                    min = j;
                swap(array, i, min);
            }
        }
    }
}
```



# 插入排序

## 描述

从第一个元素开始，该元素认为被已排序，取出下一个元素

当前索引左边的元素有序，但可能会被移动。所需时间取决于输入的元素初始序列。

时间复杂度O(n^2)，空间O(1)，稳定。

## 动图

![](insert.gif)

## 代码

```java
public class Insertion<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] a) {
        int len = a.length;
        for (int i = 1; i < len; ++i) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); --j) {
                swap(a, j, j - 1);
            }
        }
    }
}
```



# 希尔排序

## 描述

基于插入排序。思想是使数组中任意间隔为h的元素都是有序的。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。

## 动图

![](shell.gif)

## 代码

```java
public class Shell<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] a) {
        int len = a.length;
        int h = 1;
        while (h < len / 3) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            for (int i = h; i < len; ++i) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    swap(a, j, j - 1);
                }
            }
            h /= 3;
        }
    }
}

```

# 计数排序

不基于比较。算法复杂度为O(n+k)，对空间复杂度要求高。

```java
public static int[] countSrot(int[] nums){
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    int len = nums.length;
    for(int a : nums){
        max = Math.max(a, max);
        min = Math.min(a, min);
    }
    // 创建计数数组
    int[] count = new int[max - min + 1];
    int index = 0;
    // 找到每个元素出现的次数
    for(int a : nums){
        index = a - min;
        ++ count[index];
    }
    // 计算每个数字在排序后数组中应处于的位置
    for(int i = 1; i < len; ++i){
        count[i] += count[i-1];
    }
    // 根据计数数组排序
    int[] res = new int[len];
    for(int a : nums){
        index = --count[a-min];
        res[index] = a;
    }
    return res;
}
```



# 归并排序

## 描述

将一个数组递归的分成两半分别排序，然后将结果归并。

稳定排序。性能不受输入影响。时间复杂度O(NlogN)

## 动图

![](merge.gif)

## 1. 原地归并

将a[low … mid]和 a[mid + 1… hi]归并成一个有序数组，将结果存在 a[ low … hi]中。

```java
public class MergeSort<T extends Comparable<T>> extends BaseSort<T> {
    protected T[] aux;

    protected void merge(T[] a, int low, int mid, int high) {
        // 先将所有元素复制到aux[] 中，然后归并回 a[]中。
        int i = low, j = mid + 1;

        // 复制数据到辅助数组
        for (int k = low; k <= high; ++k) {
            aux[i] = a[i];
        }
        for (int k = low; k <= high; ++k) {
            if (i > mid) {
                // 左边用尽，取右边元素
                a[k] = aux[j++];
            } else if (j > high) {
                a[k] = aux[i++];
            } else if (less(aux[j], aux[i])) {
                // 右半边当前元素小于左半边当前，取右半边
                a[k] = aux[j++];
            } else {
                a[k] = aux[i++];
            }
        }
    }
}
```

## 2. 自顶向下归并排序

时间复杂度一般为O(NlogN)

```java
public class Up2DownMerge<T extends Comparable<T>> extends MergeSort<T> {
    @Override
    public void sort(T[] a) {
        aux = (T[]) new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    private void sort(T[] a, int low, int high) {
        // 这里最好这样写，否则容易出现StackOverflow 错误
        if (high <= low) {
            return;
        }
        int mid = low + (high - low) >> 1;
        // 将左半边排序
        sort(a, low, mid);
        // 右半边排序
        sort(a, mid + 1, high);
        // 归并
        merge(a, low, mid, high);
    }
}
```

## 3. 自底向上归并

```java
public class Down2UpMerge<T extends Comparable<T>> extends MergeSort<T> {
    @Override
    public void sort(T[] a) {
        int len = a.length;
        aux = (T[]) new Comparable[len];
        for (int sz = 1; sz < len; sz += sz) {
            for (int low = 0; low < len - sz; low += sz * 2) {
                merge(a, low, low + sz - 1, Math.min(low + sz + sz - 1, len - 1));
            }
        }
    }
}
```

# 快速排序

## 描述

平均时间复杂度：O(NlogN)，额外空间O(NlogN)，不稳定

## 动图

![](quick.gif)

## 基本算法

```java
public class QuickSort<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] array) {
        sort(array, 0, array.length - 1);
    }

    private void sort(T[] array, int low, int high) {
        if (high <= low) {
            return;
        }
        int j = partition(array, low, high);
        sort(array, low, j - 1);
        sort(array, j + 1, high);
    }
    
    /**
    一般写法
    **/
    private void sort2(T[] arr, int lo, int hi) {
        if (lo >= hi) {
            return;
        }
        int i = lo, j = hi;
        T k = arr[lo];
        while (i < j) {
            while (i < j && arr[j].compareTo(k) > 0) {
                j--;
            }
            if (i < j) {
                arr[i++] = arr[j];
            }
            while (i < j && arr[i].compareTo(k) < 0) {
                i++;
            }
            if (i < j) {
                arr[j--] = arr[i];
            }
        }
        arr[i] = k;
        sort(arr, lo, i - 1);
        sort(arr, i + 1, hi);
    }
}
```



## 切分

```java
private int partition(T[] a, int low, int high) {
    int i = low, j = high + 1;
    T temp = a[low];
    while (true) {
        while (less(a[++i], temp) && i != high) ;
        while (less(temp, a[--j]) && j != low) ;
        if (i >= j) {break;}
        swap(a, i, j);
    }
    // 切分值留在j中。
    swap(a, low, j);
    return j;
}

/**
     * 切分的另一种写法
     改写法在用来解决TOP K问题是，遇到如[99,99]， k=1的输入会陷入死循环
     */
private int partition2(T[] a, int low, int high) {
    T pivot = a[low];
    while (low < high) {
        // 从右向左，找到第一个小于pivot的元素
        while (low < high && less(pivot, a[high])) high--;
        // 交换
        a[low] = a[high];
        // 从左到右找到第一个大于pivot的元素
        while (low < high && less(a[low], pivot)) low++;
        a[high] = a[low];
    }
    a[low] = pivot;
    return low;
    // a[0..low-1] < pivot < a[low+1...high]
}
/**
	
**/
private int partition(int[] arr, int low, int high){
    int k = arr[low];     
    while (low<high){
        // 需要注意这里的 arr[high] >= pivot
        while (low<high && arr[high]>=k) --high;
        arr[low]=arr[high];             
        while (low<high && arr[low]<=k) ++low;
        arr[high] = arr[low];           
    }
    arr[low] = k;
    return low;
}
```

按照a[low]的值进行切分。从左向右找到第一个大于temp的元素a[i]，从右向左找到第一个小于temp的元素a[j]，交换a[i] 和 a[j]，使得i左侧的元素都不大于temp，j右侧的元素都不小于temp，i和j相遇时循环退出，交换a[low]和a[j]。

## 改进-三向快速切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。

```java
public class QuickSort3way<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] a) {
        sort(a, 0, a.length - 1);
    }

    private void sort(T[] a, int low, int high) {
        if (high < low) return;
        int lt = low, i = low + 1, gt = high;
        T v = a[low];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) {
                swap(a, lt++, i++);
            } else if (cmp > 0) {
                swap(a, i, gt--);
            } else {
                i++;
            }
        }
        // a[lo...lt-1] < v=a[lt...gt] < a[gt+1...high]
        sort(a, low, lt - 1);
        sort(a, gt + 1, high);
    }
}
```

可以提取改成partition方法

```java
public void sort(int[] a, int low, int high){
    if(high < low) return;
    // 随机快排，在low和high中随机选一个位置，即随机选一个数做划分
    swap(a, low + (int)(Math.random()* (high - low + 1)), high );
    int[] k = partition(a, low, high);
    sort(a, low, k[0] - 1);
    sort(a, k[0] +1, high);
}

private int[] partition(int[] a, int low, int high){
	int lt = low, gt = high, i = low + 1;
    int k = a[low];
    while(i <= gt){
        if(a[i] < k){
            swap(a, i++, lt++);
        }else if(a[i] > k){
            swap(a, i, gt--);
        }else{
            i ++;
        }
    }
    return new int[]{lt, gt};
}
```

**随机快排的额外空间复杂度是最好是O(longN)，最坏是O(N)**。空间用来记录断点位置。

## 使用切分解决Top K问题

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。partition()可以使用O(N)的平均复杂时间从无序数组找到第K大元素。

**注意**：使用partition找的是第K小的元素，因为partition切分后左边是小于的，右边是大于的，如果要找第K大元素，应该 `k = nums.length - k`;

可以利用这个特性找出数组的第 k 个元素。

```java
public T select(T[] nums, int k) {
    int low = 0, high = nums.length - 1;
    while (high > low) {
        int j = partition2(nums, low, high);
        if (j == k) {
            return nums[k];
        } else if (j > k) {
            high = j - 1;
        } else {
            low = j + 1;
        }
    }
    return nums[k];
}
```

### 题目二

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

[在线编程](<https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        int len = input.length;
        ArrayList<Integer> res = new ArrayList<>();
        if(len < 0 || k > len || k<=0) return res;
        int start = 0, end = len - 1;
        int index = partion(input, start, end);
        while(index != (k - 1)){
            if(index > (k-1)){
                end = index - 1;
                index = partion(input, start, end);
            }else{
                start = index + 1;
                index = partion(input, start, end);
            }
        }
        for(int i = 0;i < k;i++){
            res.add(input[i]);
        }
        return res;
    }
}
```

# 堆排序

## 描述

时间复杂度，最坏平均最好都是O(NlogN)，空间O(1)，不稳定。

## 动图

![](heapsort.gif)

## 实现

### 堆

heap[0]不放元素，根节点是heap[1]

```java
public class Heap<T extends Comparable<T>> {
    private T[] heap;
    private int n;

    public Heap(int maxN) {
        this.heap = (T[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return n == 0;
    }

    public int siza() {
        return n;
    }

    public boolean less(int i, int j) {
        return heap[i].compareTo(heap[j]) < 0;
    }

    public void swap(int i, int j) {
        T temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
```

可以将数组理解为一个堆，对于堆中的第i个节点其在数组中的下标为i，其左孩子在数组中下标为2*i+1（不越界情况）,右孩子下标为 2 * i + 2(不越界)，其父节点为 (i - 1) / 2

### 上浮

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

```java
/**
     * 节点比父节点大，上浮
     */
private void swim(int k) {
    while (k > 1 && less(k >> 1, k)) {
        swap(k >> 1, k);
        k = k >> 1;
    }
}
```

### 下沉

```java
/**
     * 父节点小于子节点，下沉
     */
private void sink(int k) {
    while ((k << 1) <= n) {
        int j = k << 1;
        // 找到两个子节点最大的那个子节点
        if (j < n && less(j, j + 1)) j++;
        if (!less(k, j)) break;
        swap(k, j);
        k = j;
    }
}
```

### 插入元素

插入到最底，然后上浮到合适位置

```java
public void insert(T a){
    heap[ ++ n] = a;
    swim(n);
}
```

### 删除最大

```java
/**
     * 删除最大元素。首先从数组顶端删除最大，将数组最后一个放在顶端，然后让该元素下沉。
     */
public T delMax(){
    T max = heap[1];
    swap(1, n --);
    heap[n+1] = null;
    sink(1);
    return max;
}
```

### 堆排序

将最大元素和当前堆中数组最后一个元素交换位置，并且不删除它，那么就可以得到一个从未到头的递减序列。

#### 构建

从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。

#### 交换堆顶与最后一个元素

交换后进行下沉操作

#### 实现

```java
public class HeapSort<T extends Comparable<T>> extends BaseSort<T> {
    @Override
    public void sort(T[] a) {
        int len = a.length;
        for (int k = len >> 1; k >= 1; k--) {
            sink(a, k, len);
        }
        while (len > 1) {
            // 交换后进行下沉操作
            swap(a, 1, len--);
            sink(a, 1, len);
        }
    }

    private void sink(T[] num, int k, int n) {
        while ((k << 1) <= n) {
            int j = k << 1;
            if (j < n && less(num[j], num[j + 1])) j++;
            if (!less(num[k], num[j])) break;
            swap(num, k, j);
            k = j;
        }
    }
}
```

### 分析

堆高度为logN，插入删除的复杂度都是logN。

堆排序对N个节点进行下沉，复杂度NlogN。

没有利用额外空间。没有利用局部性原理缓存。

## 题目

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

[在线编程](<https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

### 利用堆解决

使用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。

时间：O(nlogk)

Java中的优先队列(`PriorityQueue`)是基于堆实现的，默认是自然排序，即默认构造最小堆，如果要更改排序规则，可以在构造时使用`Comparator`指定。优先队列中的元素可以通过Compartor定义规则。

```java
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
        int len = input.length;
        ArrayList<Integer> res = new ArrayList<>();
        if (k <= 0 || len < k) return res;
        PriorityQueue<Integer> maxHeap =
                new PriorityQueue<>(k, Comparator.reverseOrder());

        // 将数组中的元素入堆
        for (int a : input) {
            if (maxHeap.size() < k) {
                maxHeap.offer(a);
            } else if (maxHeap.peek() > a) {
                maxHeap.poll();
                maxHeap.offer(a);
            }
        }

        res.addAll(maxHeap);
        return res;
    }
}
```



# 总结

![](all.png)



稳定性定义：经过排序之后,能使值相同的数据保持原顺序中的相对位置不变

稳定性口诀：

>  快选堆希不稳（快速排序，选择排序，堆排序，希尔排序）
>
> 插冒归计基稳（插入排序，冒泡排序，归并排序，计数，基数）

# 参考

* 《算法》第四版
* [博客园 - 十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)
* [被忽视的 partition 算法](<https://selfboot.cn/2016/09/01/lost_partition/>)
* [OSCHINA - 基于堆实现的优先级队列：PriorityQueue 解决 Top K 问题](<https://my.oschina.net/leejun2005/blog/135085>)