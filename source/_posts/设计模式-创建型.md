---

title: 设计模式-创建型
date: 2019-04-15 16:50:03
tags: 设计模式
categories: 设计模式
---

设计模式中的创建型模式。创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。包括单例，简单工厂，工厂方法，抽象工厂，生成器，原型模式。

<!--more-->	

# 1. 单例模式（重要）

## 为什么使用

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

* 频繁操作的对此昂，省略创建对象花费的时间
* new操作次数减少，因而对系统的内存使用降低，减少GC压力

为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源。

## 实现方式

**饿汉模式**：全局的单例实例在类装载时构建。JVM在加载这个类时就马上创建此唯一的单例实例，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。

**懒汉模式**：全局的单例实例在第一次被使用时构建。单例实例在第一次被使用时构建，而不是在JVM在加载这个类时就马上创建此唯一的单例实例。

单例类有一个private的构造函数；instance成员变量和uninstance方法是static的

构造方法声明为private,使得无法从外部类来实例化对象，然后在类内部的方法中返回实例化的单一对象。

### 1. 饿汉模式

```java
public class Singleton {
    // new Singleton() 堵死
    private Singleton() {};
    // 私有静态实例，该类第一次使用进行创建
    private static Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
}
```

在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。一般情况下使用。

### 2. 懒汉模式(线程不安全)

```java
public class Singleton {
    private Singleton() {
    }
    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例

### 3. 懒汉模式 （线程安全）

```java
public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
```

使用 `synchronized`,每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，

### 4. 双重检查模式（DCL）- 懒汉式

```java
public class Singleton {
    private Singleton(){}
    private volatile static Singleton instance;
    public static Singleton getInstance(){
        // 检查实例，不存在进入同步代码块
        if(instance == null){
            synchronized (Singleton.class){
                // 进入同步代码块后再次检查，如果null，创建实例
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

双重检验锁模式（double checked locking pattern），两次检验instance是否为null。

### 5. 嵌套类类单例模式（推荐）- 懒汉式

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCEE = new Singleton();
    }

    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCEE;
    }
}
```

Singleton类被加载时，静态内部类SingletonHolder没有被加载进内存，只有当调用getInstance()方法，触发` SingletonHolder.INSTANCEE`，SingletonHolder才被加载，此时初始化INSTANCE实例，且JVM确保INSTANCE只实例化一次。**使用JVM本身机制保证了线程安全问题**；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。

### 6. 枚举类（最佳）

```java
public enum EasySingleton{
    INSTANCE;
}
```

实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。

## 总结

一般情况下使用第一种 **饿汉模式**，明确要求要懒加载（lazy initialization），使用第五种静态内部类。涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。

*  [深入理解单例模式——只有一个实例](https://blog.csdn.net/qq_34337272/article/details/80455972)

# 2. 简单工厂模式

简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。

```java
public class SimpleFactory {
    public Product createProduct(int type){
        if(type == 1){
            return new ConcreteProduct1();
        } else if(type == 2){
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
```

# 3. 工厂模式（重要）

**每个对象都有一个与之对应的工厂**

意图：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。

为什么使用工厂模式：1. 解耦：将对象的创建和使用分离。2. 降低代码重复。3. 降低代码维护。



Spring中的IOC就用到了工厂模式。

![](factorymethod.jpg)

```java
public interface FoodFactory{
    Food makeFood(String name);
}

public class ChineseFoodFactory implements FoodFactory{
    @Override
    public Food makeFood(String name){
        if (name.equals("A")) {
            return new ChineseFoodA();
        } else if (name.equals("B")) {
            return new ChineseFoodB();
        } else {
            return null;
        }
    }
}

public class AmericaFoodFactory implements FoodFactory{
    @Override
    public Food makeFood(String name){
        return new AmericaFood(name);
    }
}
```

调用

```java
public class App{
    public static void main(String[] args){
        // 选择具体工厂
        FoodFactory fac = new ChineseFoodFactory();
        // 由工厂生产对象
        Food food = fac.makeFood("A");
    }
}
```

# 4. 抽象工厂模式

意图：提供一个接口，用于创建 **相关的对象家族** 。主要解决接口选择问题。

![](abstract-factory-3.png)

```java
public static void main(String[] args){
    // 建造大厂
    ComputerFactory cf = new AmdFactory();
    Cpu cpu = cf.makeCpu();
    Disk disk = cf.makeDisk();
    // 组装
    Computer res = new Computer(cpu, disk);
}
```

# 5. 建造者模式

```java
class User {
    private String name;
    private String pass;
    private String nickName;
    private int age;

    private User(String name, String pass, String nickName, int age) {
        this.name = name;
        this.pass = pass;
        this.nickName = nickName;
        this.age = age;
    }

    // 静态方法，生成一个Builder
    public static UserBuilder builder() {
        return new UserBuilder();
    }

    public static class UserBuilder {
        // 下面是和 User 一模一样的一堆属性
        private String name;
        private String pass;
        private String nickName;
        private int age;

        private UserBuilder() {
        }

        // 链式调用各个属性值，返回UserBuilder
        public UserBuilder name(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder pass(String pass) {
            this.pass = pass;
            return this;
        }

        public UserBuilder nickName(String nickName) {
            this.nickName = nickName;
            return this;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。

        public User build() {
            return new User(name, pass, nickName, age);
        }
    }
}
```



# 6. 原型模式

意图：原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。

```java
public abstract class Prototype{
    abstract Prototype myClone();
}
```

```java
public class ConcretePrototype extends Prototype{
    String filed;
    public ConcretePrototype(Stirng filed){
        this.filed = filed;
    }
    
    @Override
    Prototype myClone() {
        return new ConcretePrototype(filed);
    }
}
```

Object 类中有一个 clone() 方法，它用于生成一个新的对象，java 要求我们的类必须先**实现 Cloneable 接口**，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。

java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。









# 参考

* [Javadoop - 设计模式也可以这么简单](<https://www.javadoop.com/post/design-pattern>)
* [CS-Notes - 设计模式](<https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md>)
* [设计模式（二）单例模式的七种写法](https://blog.csdn.net/itachi85/article/details/50510124)
* [菜鸟教程-单例模式](http://www.runoob.com/design-pattern/singleton-pattern.html)