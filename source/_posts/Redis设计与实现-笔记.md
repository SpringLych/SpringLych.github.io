---
title: Redis设计与实现-笔记
date: 2019-05-09 20:18:40
tags: Redis
categories: Redis
---

《Redis设计与实现》读书笔记，和其他资料，

<!--more-->

## Redis使用场景

### 计数器

对String进行自增自减。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

### 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

### 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

### 消息队列

List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息

不过最好使用 Kafka、RabbitMQ 等消息中间件。

### 实时消息系统

通过发布与订阅实现

### 其他

Set 可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet 可以实现有序性操作，从而实现排行榜等功能。

## 简单动态字符串

相比于C字符串，SDS的优点：

1.  O(1)时间复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符串长度时所需的内存重新分配次数。
   1. 空间预分配。
   2. 惰性空间释放。
4. 二进制安全。
5. 兼容部分C字符串函数。

## 链表

1. Redis的链表是双端链表，是无环链表。每个节点都有一个前指针和后指针。
2. Redis中的链表实现了很多功能，如列表键，发布与订阅，慢查询，监视器等。

## 字典

1. 字典用于：数据库和哈希键等。
2. 使用哈希表作为字典的底层实现，每个字典两个哈希表，一个平时使用，另一个在rehash是使用。
3. 哈希表使用渐进式rehash进行扩容或收操作。
4. 哈希表使用链地址法解决哈希冲突。同一个索引上的多个键值连接成一个单向链表。（类似Java中HashMap解决哈希冲突）
   1. 备注：常用四种解决哈希冲突方法：开放定址法，链地址法，再哈希，建立公共溢出区。

## 跳跃表

1. 跳跃表是有序集合的底层实现之一
2. 每个跳跃表节点的层高都是1至32之间的随机数。
3. 同一个跳跃表中，多个节点可以有相同的分值，成员对象必须是唯一的。
4. 跳跃表中节点按分值大小排序，分值相同，节点按照成员对象大小排序。

与红黑树相比，跳跃表的优点：

1. 实现简单
2. 插入速度快速，不需要进行旋转
3. 支持无锁操作。31

## 整数集合

1. 是集合键的底层实现之一
2. 底层为数组，有序，无重复的保存集合元素，有需要时，会根据新添加元素的类型，改变数组的类型。
3. 升级好处：提升灵活性（不必担心类型错误），节约内存。
4. 只支持升级，不支持降级。

## 压缩列表

1. 为节约内存而开发的顺序型数据结构
2. 列表建和哈希键的底层实现之一
3. 添加新节点，或者删除新节点，可能引发连锁更新（每个节点previous_entry_length更新），但出现几率不高。
4. 可以包含多个节点，每个节点可以保存一个字节数组或者整数值。 

## 对象

1. 数据库中每个键值对的键和值都是一个对象。
2. Redis共享值为0-9999的字符串对象。 

### 字符串对象

编码：int, raw, embstr

long类型的整数---int

long double类型的浮点数 --- embstr或raw

字符串值或长度大的long类型 --- embstr或raw。

embstr编码的对象被修改时总会变成raw编码。

### 列表对象

编码：ziplist或linkedlist(底层使用双端列表)

使用ziplist编码的条件：列表对象所有字符串长度都不小于64字节。列表对象保存的元素数量小于512个。

### 哈希对象

编码：ziplist（底层压缩列表）或hashtable（字典）

### 集合对象

编码：intset(底层整数集合)或hashtable(底层字典)

### 有序集合对象

编码：ziplist 或 skiplist

### 内存回收

使用**引用计数**实现内存回收机制。对象不再被使用时就回收。

对象的生命周期：创建对象，操作对象，释放对象。

### 对象共享

通过对象的引用计数属性实现。

多个键共享一个值对象：

1. 数据库键的值指向一个现有值对象
2. 被共享的值对象引用计数增一。

Redis在初始化时，创建一万个字符串对象(0 - 9999的整数值)。用到时，服务器共享这些对象。

## 持久化

### RDB持久化

* 将某个时间点的所有数据都存放到硬盘上。保存数据库中的键值对

* 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

* 如果系统发生故障，将会丢失最后一次创建快照之后的数据。

* 如果数据量很大，保存快照的时间会很长。

* 两种生成RDB文件的命令：SAVE, BGSAVE

* SAVE命令由服务器进程执行操作，会阻塞服务器。BGSAVE命令由子进程执行，不会阻塞服务器。

* RDB文件是一个经过压缩的文件

* 如果开启了AOF持久化，会首先使用AOF文件

### AOF持久化

* 通过保存Redis服务器所执行的写命令记录数据库状态
* AOF文件所有命令都以Redis命令请求协议格式保存。
* appendfsync选项对AOF持久化功能的安全性和Redis服务器的性能有很大影响。
* 服务器载入并执行AOF文件中的命令还原数据库。
* AOF重写产生性的AOF文件，保存状态一样，体积更小
* AOF重写通过读取数据库中的键值对实现，
* 使用 BGREWRITEAOF命令，完成AOF文件重写。

## 对比Memchached

两者都属于内存 键值关系型数据库。

### 数据类型

Redis支持五中数据类型，Memchached仅支持字符串类型。

### 持久化

Redis支持AOF日志和RDB快照两种持久化策略，memchached不支持。

### 分布式

Redis Cluster实现分布式支持。Memchached不支持。

### 内存管理

在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。

Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

## 事务

* Redis中的事务具有ACID的特性
* 多个命令进入到事务队列中，按照FIFO顺序执行。





## 参考

* [黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.](http://redisbook.com/index.html)

* [CS-Notes - Redis](<https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md>)